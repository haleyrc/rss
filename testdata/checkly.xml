<rss xmlns:dc="http://purl.org/dc/elements/1.1/" 
    xmlns:content="http://purl.org/rss/1.0/modules/content/" 
    xmlns:atom="http://www.w3.org/2005/Atom" 
    xmlns:media="http://search.yahoo.com/mrss/" version="2.0">
    <channel>
        <title>
            <![CDATA[ The Checkly Blog ]]>
        </title>
        <description>
            <![CDATA[
The Checkly Blog is your go-to place for technical stories on building a SaaS, building a company and growing it from scratch.
]]>
        </description>
        <link>https://blog.checklyhq.com/</link>
        <image>
            <url>https://blog.checklyhq.com/favicon.png</url>
            <title>The Checkly Blog</title>
            <link>https://blog.checklyhq.com/</link>
        </image>
        <generator>Ghost 2.19</generator>
        <lastBuildDate>Mon, 08 Apr 2019 21:40:21 GMT</lastBuildDate>
        <atom:link href="https://blog.checklyhq.com/rss/" rel="self" type="application/rss+xml"/>
        <ttl>60</ttl>
        <item>
            <title>
                <![CDATA[
Our Stripe Billing implementation and the one webhook to rule them all
]]>
            </title>
            <description>
                <![CDATA[
This is how we configured Stripe Billing for our SaaS and it hooked it up to our backend. We only use one webhook to keep all things running smoothly.
]]>
            </description>
            <link>
https://blog.checklyhq.com/our-stripe-billing-implementation-the-one-webhook-to-rule-them-all/
            </link>
            <guid isPermaLink="false">5ca7cf3db8aecf00cc47c960</guid>
            <category>
                <![CDATA[ building a saas ]]>
            </category>
            <category>
                <![CDATA[ development ]]>
            </category>
            <category>
                <![CDATA[ javascript ]]>
            </category>
            <dc:creator>
                <![CDATA[ Tim Nolet ]]>
            </dc:creator>
            <pubDate>Mon, 08 Apr 2019 18:36:48 GMT</pubDate>
            <media:content url="https://blog.checklyhq.com/content/images/2019/04/money-shower-yoshitora-japanese-woodblock_1_614241d00d1c50a81398a3028fec37b1.jpg" medium="image"/>
            <content:encoded>
                <![CDATA[
<img src="https://blog.checklyhq.com/content/images/2019/04/money-shower-yoshitora-japanese-woodblock_1_614241d00d1c50a81398a3028fec37b1.jpg" alt="Our Stripe Billing implementation and the one webhook to rule them all"><p>When I started Checkly, all the typical SaaS things around billing, credit cards and prorating confused the hell out of me. I understood them from an intellectual point of view, but not really from an implementation point of view.</p><p>Sure, I hooked up some payment providers (Adyen, Paypal) at previous jobs. But I was never in the position to <em>really</em> connect the dots between the software bits and the business bits. I was also never part of a "pure" SaaS player before Checkly.</p><h2 id="choosing-a-subscription-billing-provider">Choosing a subscription billing provider</h2><p>Writing a subscription billing backend yourself is of course nuts. That's why companies like <a href="https://chargebee.com">Chargebee</a>, <a href="https://recurly.com">Recurly</a>, <a href="https://chargify.com">Chargify</a> and others exist.</p><p>Funnily, what I didn't know before starting Checkly is that Stripe never had a recurring subscriptions product. They <a href="https://stripe.com/newsroom/news/stripe-launches-billing">launched it</a> in April 2018, right when I was just getting out of private beta. So I integrated Stripe Billing, because I thought it was the thing everyone did when they "integrated Stripe". </p><h2 id="our-stripe-billing-setup">Our Stripe Billing setup</h2><p>I'm not going to duplicate the <a href="https://stripe.com/docs/billing/quickstart">Stripe Billing docs</a> here, but I'll pick out some details that were not completely obvious to me when implementing this and required some iterations to get right.</p><p>First a primer on the core Stripe Billing entities:</p><ul><li><strong>Products</strong> describe the plans you can subscribe to. Notice how products are very generic buckets. They are the canonical names you refer to when talking to customer. "Would you like one fresh Developer plan?".  No cryptic names or back office only IDs.</li></ul><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.checklyhq.com/content/images/2019/04/image-1.png" class="kg-image" alt="Our Stripe Billing implementation and the one webhook to rule them all"><figcaption>Stripe Billing products</figcaption></figure><!--kg-card-end: image--><ul><li>Each product has <strong>pricing plans. </strong>These are the entities your users actually subscribe to. You can have multiple pricing plans, for example for the yearly and monthly subscription cycle. <br><br>Notice we have a &lt;cycle&gt;-&lt;price&gt; naming scheme going on and we have multiple Monthly and multiple Yearly entries. This is because we are changing and tweaking prices as Checkly matures. This way we can <strong>grandfather</strong> early customers into their pricing plan. So, with each change in pricing, you add a pricing plan instead of editing the one that's already there.</li></ul><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.checklyhq.com/content/images/2019/04/image-2.png" class="kg-image" alt="Our Stripe Billing implementation and the one webhook to rule them all"><figcaption>Stripe Billing pricing plans</figcaption></figure><!--kg-card-end: image--><ul><li>Users have <strong>subscriptions</strong> to pricing plans. This determines what they are billed for each period. This entity has periods assigned to it, invoices, billing method etc. Basically all the active parts of the Stripe Billing system, whereas the other parts are mostly static configuration. <br><br>Here's an overview of our "Monthly-29" pricing plan subscribers.</li></ul><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.checklyhq.com/content/images/2019/04/image-3.png" class="kg-image" alt="Our Stripe Billing implementation and the one webhook to rule them all"><figcaption>Subscribers to the Monthly-29 plan</figcaption></figure><!--kg-card-end: image--><ul><li>You can also have <strong>tiered </strong>pricing and <strong>metered usage</strong> pricing. We are not using the metered usage pricing at this stage so I have no comment on it. However, we are starting with the tiered pricing. The "Browser Check Bundle" product in the above screenshot is an example.<br><br>Tiered pricing allows you to add extra whatever™<strong></strong>items to a pricing plan where the eventual price is based on the quantity added. <br><br>For Checkly, this was great when customers asked if they can get some extra browser checks above their plan limit, but without needing to upgrade to the next plan level. For example, our Starter plan gives you five browser checks, but you need eight. You don't want to opt for the Growth plan. No problem, we can add the overage of three to your plan using this bundle. Boom, sales 💵<br><br>The tiering allows you to assign different unit prices per volume. This is commonly used to give discounts for higher volumes, i.e. the first ten are $3 per unit and from there on $2 per unit.<br><br>See the example below of a standard subscription with a tiered check bundle.</li></ul><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://blog.checklyhq.com/content/images/2019/04/image-5.png" class="kg-image" alt="Our Stripe Billing implementation and the one webhook to rule them all"></figure><!--kg-card-end: image--><h2 id="hooking-it-up">Hooking it up</h2><p>Looks great, nice pictures. But how do you hook it up to your SaaS backend? Here's how we do it at Checkly. I'm going to explain it by going through a typical customer signup process.</p><h3 id="1-just-browsing">1. Just browsing</h3><p>A potential customer hits our landing page and checks out the pricing page. Nothing happens with Stripe. The pricing is hard coded. The shame. 😱</p><h3 id="2-trial">2. Trial</h3><p>Our potential customer is convinced Checkly will change his/her life. A trial is started. Nothing happens with Stripe, although Stripe does have an option to mark a subscription with a trial period. I found no good use for it.</p><h3 id="3-paid-plan">3. Paid plan</h3><p>We're on! A user selects a paid plan and fills out the typical form for name, address, credit card details etc. Most of the implementation here is a custom Vue.js form, with the exception of the credit card field. This is actually an iframe directly hosted on Stripe's backend. Most of this is fairly well covered in <a href="https://stripe.com/docs/stripe-js">the original docs</a>.</p><p>The billing period selectors are still using hard coded pricing information in the frontend.  Again, the shame. 😲</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://blog.checklyhq.com/content/images/2019/04/image-6.png" class="kg-image" alt="Our Stripe Billing implementation and the one webhook to rule them all"></figure><!--kg-card-end: image--><p>The user <strong>hits the submit button</strong> and an API cha cha cha begins between Checkly and Stripe. </p><p>What are the interesting bits here, without regurgitating the Stripe docs? Let's look at a slightly redacted version of the actual controller code from our Hapi.js based API.</p><!--kg-card-begin: markdown--><pre><code class="language-javascript"> create (request, reply) { const { token, planName, interval, accountId, details } = request.payload let account = null let stripeSubscriptionId = null let plan = {} Promise.all([ Account.query().findOne({ id: accountId }), Plan.query().findOne({ name: planName })]) .then(res =&gt; { account = res[0] plan = res[1] stripeSubscriptionId = account.stripeSubscriptionId if (stripeSubscriptionId) { return _updateSubscription(accountId, stripeSubscriptionId, plan, interval, details) } else { return _createSubscription(accountId, token, plan, interval, details) } }) .then(res =&gt; { reply(res) }) .catch(err =&gt; { reply.badImplementation(err) }) } </code></pre><!--kg-card-end: markdown--><ol><li>We grab the payload data from the <code>POST</code> to our API endpoint. The <code>token</code> is crucial as it is signed by Stripe directly from the browser. This functions somewhat like a one time password for linking the credit card details the user supplied to Stripe using the iframe. <br>The <code>planName</code> and <code>interval</code> are also crucial for obvious reasons. Let's assume in this case they are "Starter" and "Monthly". </li><li>We fire of two queries in parallel: One for the account, one for the plan. <br>If the account already has a subscription, we call a function to update the subscription. This allows users to upgrade or downgrade. Stripe handles all the finicky billing details with prorating. If the customer is brand new, we call a function to create a new subscription. <br><br>The plan query returns, among other things, a column that contains the pricing plan ID as it is registered in Stripe. Note we fetch the plan by its canonical name, i.e. "Starter" and we store the specific current pricing plan  ID as a separate column in that row.</li></ol><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.checklyhq.com/content/images/2019/04/image-10.png" class="kg-image" alt="Our Stripe Billing implementation and the one webhook to rule them all"><figcaption>The "plans" table. The "trial" and "price" columns are actually not used anywhere. They are debris from an early iteration when I hadn't really figured everything out yet.</figcaption></figure><!--kg-card-end: image--><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.checklyhq.com/content/images/2019/04/image-8.png" class="kg-image" alt="Our Stripe Billing implementation and the one webhook to rule them all"><figcaption>Stripe Billing pricing plan example</figcaption></figure><!--kg-card-end: image--><p>Let's look at the <code>_createSubscription()</code> function a bit closer<em>. </em></p><!--kg-card-begin: markdown--><pre><code class="language-javascript">function _createSubscription (accountId, token, plan, interval, details) { let customer = null return StripeService.createCustomer(token, details) .then(res =&gt; { customer = res return SalesTaxService.getSalesTax(details.country, details.vatNumber) }) .then(tax =&gt; { const taxPercent = tax.rate * 100 || 0.00 const stripepPlanId = toStripePlanId(plan.planId, interval) return StripeService.createSubscription(customer.id, stripePlanId, taxPercent) }) .then(subscription =&gt; { return Account .query() .update({ planId: plan.id, planInterval: interval, stripeCustomerId: customer.id, stripeSubscriptionId: subscription.id, maxApiChecks: plan.maxApiChecks, maxBrowserChecks: plan.maxBrowserChecks, maxSMS: plan.maxSMS, maxDashboards: plan.maxDashboards, features: plan.features, currentPeriodEnds: calculateCurrentPeriodEnds(interval) }) .where({id: accountId}) }) } </code></pre><!--kg-card-end: markdown--><p>Lot's of interesting stuff happening here.</p><ol><li>We call a <code>createCustomer()</code> method on our Stripe service. This is just a thin wrapper around the Stripe Node.js SDK. It returns a new customer. Yay 🎉</li><li>We call a custom <code>SalesTaxService</code> which is another thin wrapper around the super excellent <a href="https://www.npmjs.com/package/sales-tax">node-sales-tax package</a>. I'll do a post on this some other time, suffice to say you don't really need a third party SaaS to do your sales tax.</li><li>After we know our sales tax, we call <code>createSubscription()</code> which actually creates the subscription for our new customer. <br>The <code>toStripePlanId()</code> helper function has an important job here, as based on the interval passed in it appends the string <code>-year</code> to the plan ID. This is how we distinguish between signing up a customer to the monthly or yearly version of a plan.</li><li>After the subscription is created, we copy over all the relevant plan details to the account record. Most important are the the plan volume limits and features. Also, we set the date when this plan expires in the <code>currentPeriodEnds</code> field. We use that <em>all over</em> the backend and frontend to show messages and determine if a user is allowed to do things or not. See the previous two posts on this blog.</li></ol><p>The<em></em><code>updateSubscription()</code> function is just a minor variation on this theme.</p><h2 id="the-one-webhook-to-rule-them-all">The one webhook to rule them all </h2><p>Ok, customer is hooked up, subscription created and first payment in the pocket. What happens next month (or year) when the subscription renews? </p><p>Stripe informs you of all things happening in their backend with webhooks. This is super common and not very interesting by itself. </p><p>What is interesting, is that you can probably scrape by in the beginning of your SaaS product by listening to just one webhook:</p><p><strong>invoice.payment_succeeded</strong><br><br>hallowed be thy name 🤘</p><p>The webhook is send out when the automatically generated Stripe Billing invoice has been connected with an actual, validated payment.</p><p>And yes, you will need to listen to more webhooks later down the road (I think) and this is really basic, but it works really well for a ton of things. Here's what our code looks like for the API endpoint we direct all Stripe webhooks to.</p><!--kg-card-begin: markdown--><pre><code class="language-javascript"> hooks (request, reply) { const signature = request.headers['stripe-signature'] const event = StripeService.getEvent(request.payload, signature) switch (event.type) { case 'invoice.payment_succeeded': _updateAccountOnPayment(event) .then(() =&gt; { return _doInvoicingStuff(event) }) .then(() =&gt; { reply() }) .catch(err =&gt; { reply.badImplementation(err) }) break default: console.log(`no action for Stripe event ${event.type}`) return reply() } } </code></pre><!--kg-card-end: markdown--><ol><li>We catch all webhook messages and validate them using the standard <strong>signature</strong> validation Stripe recommends. This makes sure the message actually came from Stripe.</li><li>We have a typical case <code>switch</code> statement and only act on the holy <code>invoice.payment_succeeded</code> event type.</li><li>The <code>_updateAccountOnPayment()</code> function is so simple I'm not going to show the code. Essentially it just bumps the <code>currentPeriodEnds</code> field for the account. This now functions as a safeguard for all kinds of billing problems like cancelling customers, failing credit cards etc. There are corner cases of course, but you can deal with them by hand. This takes care of 98% of your normal billing cycle.</li><li>The <code>_doInvoicingStuff()</code> method is something for another blog post, but it creates, updates and sends the correct invoices from our <a href="https://www.moneybird.nl/">Moneybird</a> accounting system. For Dutchies only. Gezellig 🇳🇱 🧀</li></ol><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><p>banner image: Yoshitora (active 1850-1880), "Money Shower", Japan,  <a href="https://www.worthpoint.com/worthopedia/money-shower-yoshitora-japanese-woodblock">source</a></p>
]]>
            </content:encoded>
        </item>
        <item>
            <title>
                <![CDATA[
How we deal with plan limits in the front end of our SaaS app
]]>
            </title>
            <description>
                <![CDATA[
If you run a SaaS, you probably want to show a user that he/she is almost running out of widgets. Or that he/she can get some cool feature on a more expensive plan. In this post we look at how implemented this in our Vue.js frontend application.
]]>
            </description>
            <link>
https://blog.checklyhq.com/how-we-deal-with-plan-limits-in-the-frontend-of-our-saas-app/
            </link>
            <guid isPermaLink="false">5ca0f91131364200c0893c68</guid>
            <category>
                <![CDATA[ building a saas ]]>
            </category>
            <category>
                <![CDATA[ development ]]>
            </category>
            <category>
                <![CDATA[ javascript ]]>
            </category>
            <dc:creator>
                <![CDATA[ Tim Nolet ]]>
            </dc:creator>
            <pubDate>Sun, 31 Mar 2019 20:38:27 GMT</pubDate>
            <media:content url="https://blog.checklyhq.com/content/images/2019/03/VMFA_Hasui_2006-345_v1TF201503_700x450.jpg" medium="image"/>
            <content:encoded>
                <![CDATA[
<img src="https://blog.checklyhq.com/content/images/2019/03/VMFA_Hasui_2006-345_v1TF201503_700x450.jpg" alt="How we deal with plan limits in the front end of our SaaS app"><p>If you run a SaaS, you probably want to show your users when they are almost running out of widgets. Or that they can get some cool feature on a more expensive plan. Or, in other words, how can you be nice <em>and </em>commercial in dealing with plan limits.</p><p>Last week we already looked at <a href="https://blog.checklyhq.com/how-we-manage-plans-features-in-our-saas-app/">how we manage plans &amp; features</a> for Checkly. That write up was very back end focused, so this week I wanted to dive deeper into how we actually show this to our users in a friendly way. </p><p>We use <a href="https://vuejs.org/">Vue.js</a> with <a href="https://vuex.vuejs.org/">Vuex</a> for our front end, but the patterns and code examples here can be applied to any other SPA framework.</p><h2 id="types-of-plan-limits">Types of plan limits</h2><p> Short recap of the types of plan limits we recognized in the <a href="https://blog.checklyhq.com/how-we-manage-plans-features-in-our-saas-app/">last writeup</a>.</p><ol><li><strong>Paying vs. lapsing</strong>: You are a paying customer or on a trial / stopped paying.</li><li><strong>Plan based feature toggles</strong>: A feature is enabled on your plan or not.</li><li><strong>Plan based volume limits</strong>: You are allowed ten of these and five of those.</li></ol><p>We also mentioned role based access control but I wanted to keep that for another write up. </p><h2 id="the-basic-setup">The basic setup</h2><p>We need to keep track of a bunch of fairly global variables, some fairly static — plan expiry date for yearly payers changes once a year— some that dynamically change as the user interacts with the app.</p><p>However, we do not want to bother all of our frontend components with the logic to control and validate these cross cutting concerns. We want to expose a dedicated — dare I say singleton — object that encapsulates the current state of all of plan and user logic.</p><p>For this we use Vue.js and Vuex, a Redux-type central data store. On initial page load, we populate an object using <em>actions</em> and <em>mutations </em>(two very specific Vuex things I won't go into much deeper here) with the things we are interested in. </p><p>Or, in pre-Javascript-frameworks-are-eating-the-world-speak, you fire an XHR request when a user logs in, your backend returns all account data, you parse it into a palatable object. </p><p>Here is what such an object looks like. It's an almost exact copy &amp; paste from the excellent <a href="https://github.com/vuejs/vue-devtools">Vue.js debug tool</a>.</p><!--kg-card-begin: markdown--><pre><code class="language-javascript">{ isPayingCustomer: true, currentAccount: { features: ['SMS_ALERTS', 'TEAMS', 'PROMETHEUS', 'TRIGGERS'] }, expiryStatus: { daysTillTrialExpiry: 24 planHasExpired: false }, isFeatureLimited: { accountUsers: true apiChecks: true browserChecks: false dashboards: false }, } </code></pre><!--kg-card-end: markdown--><p>Notice a couple of things:</p><ol><li>We transform almost all properties into <code>isSomething</code> or <code>hasSomething</code> forms. This makes your code nicer in the components that use this later.</li><li>We have a <code>currentAccount</code> object because a user can be a member of multiple accounts and can switch between them during a session.</li><li>Strictly speaking, the <code>expiryStatus</code> object holds superfluous data. But we don't want every component that uses this to implement the boolean function <code>planHasExpired</code> based on the <code>daysTillTrialExpiry</code> property.</li><li>This representation is pretty different from how we store it on our backend. It is <strong>specifically tailored to be useful in the frontend</strong>.</li></ol><p>That last bullet is kinda important, I figured out after a while. Here comes a quote:</p><blockquote>How things are stored on your backend should never determine how you use them in your frontend.</blockquote><p>This is probably material for another post, but very essential to self starting, full stack developers. You need to cross the chasm. Backend and frontend are not the same.</p><p>Let's look at some examples now.</p><h2 id="example-1-plan-expiry-nag-screen">Example 1: Plan expiry nag screen</h2><p>This is what appears at the top of you navigation bar in Checkly if you are dangerously close to your plan expiring. This happens only on two occasions:</p><ol><li>You are a trial user and haven't upgraded yet.</li><li>You are a paying member of our secret and exclusive society, but for some unspoken reason your credit card failed.</li></ol><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.checklyhq.com/content/images/2019/03/Screen-Shot-2019-03-31-at-20.09.23.png" class="kg-image" alt="How we deal with plan limits in the front end of our SaaS app"><figcaption>Example of plan expiry nag message</figcaption></figure><!--kg-card-end: image--><p>To conjure up this message, we use the following code. Note we use  Jade/Pug for templating but it should translate to plain HTML quite easily.</p><!--kg-card-begin: markdown--><pre><code> .navbar-upgrade-notice(v-if='showUpgradeTeaser') | You have only {{expiryStatus.daysTillTrialExpiry}} day(s) left in your trial! router-link(:to=&quot;{ name: 'billing:plans' }&quot;) Upgrade your plan .navbar-upgrade-notice(v-if='showExpiredTeaser') | Your trial has expired! router-link(:to=&quot;{ name: 'billing:plans' }&quot;) Upgrade your plan </code></pre><!--kg-card-end: markdown--><p>Two things are happening here:</p><ol><li>We have an <code>if</code> statement on the <code>showUpgradeTeaser</code> and <code>showExpiredTeaser</code> booleans. If they are false, we don't show 'm. You get it. </li><li>We directly use the <code>expiryStatus</code> object and tap into the <code>daysTillTrialExpiry</code> property to let the user know how long he/she has.</li></ol><p>But how do we get this data from the central data store? And how do we set that <code>showUpgradeTeaser</code> property? For this we leverage Vue.js's <a href="https://vuejs.org/v2/guide/computed.html">computed properties</a>. They are absolutely awesome and I use them as much as I can. </p><p>Simply put, they are properties they are constantly updated based in changing inputs. "Reactive" if you will. In most frameworks, this code lives in the <em>controller</em> of your frontend component, although Vue.js does not call them that.</p><p>Here's a look at a part of the code of our navigation bar component. </p><!--kg-card-begin: markdown--><pre><code class="language-js"> computed: { expiryStatus() { this.$store.getters.expiryStatus }, showUpgradeTeaser () { return this.expiryStatus ? (this.expiryStatus.daysTillTrialExpiry &gt; 0 &amp;&amp; this.expiryStatus.daysTillTrialExpiry &lt; 5) : false }, showExpiredTeaser () { return this.expiryStatus ? this.expiryStatus.planHasExpired : false } } </code></pre><!--kg-card-end: markdown--><p>You can see how the <code>showUpgradeTeaser</code> and <code>showExpiredTeaser</code> are created. They directly tap into the <code>expiryStatus</code> object, which is exposed to the local <code>this</code> context by a very Vue.js specific way of getting data from a Vuex store. Your framework will have a similar thing. Also notice we start show the upgrade teaser from the last five days till a plan expires.</p><h2 id="example-2-plan-volume-limit-reached">Example 2: plan volume limit reached</h2><p>This is what a user sees when they try to create one more check when they already are at their plan limit.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.checklyhq.com/content/images/2019/03/Screen-Shot-2019-03-31-at-20.15.45.png" class="kg-image" alt="How we deal with plan limits in the front end of our SaaS app"><figcaption>Example of plan volume message</figcaption></figure><!--kg-card-end: image--><p>We explicitly want a user to be notified about his/her plan limit the moment that creating a new check is relevant. There is probably a very good commercial reason for that and that is why all SaaS companies do it [citation needed].</p><p>Here's a snippet of our frontend code. It follows the exact same pattern as the example above:</p><!--kg-card-begin: markdown--><pre><code class="language-js">.dropdown-item(v-if='isFeatureLimited.apiChecks || expiryStatus.planHasExpired') .check-icon .title API check router-link(:to=&quot;{ name: 'billing:plans' }&quot;) Upgrade your plan .button-text You maxed out the API checks in your account. </code></pre><!--kg-card-end: markdown--><p>Again, it taps into the <code>expiryStatus</code> object but this time also into the <code>isFeatureLimited</code> object. Together, they decide whether to show the upgrade button (and block creating a new check) or not.</p><p>The <code>isFeatureLimited</code> object encapsulates the state of a plan and if it is over its assigned volume limits for a specific resource; in our case API checks and browser checks. </p><p>This is actually a bit more complicated than it seems. We, again, deal with it in our central data store. Here's a snippet:</p><!--kg-card-begin: markdown--><pre><code class="language-js"> isFeatureLimited: (state, getters) =&gt; { return { apiChecks: getters.checks.filter(check =&gt; { return check.checkType === 'API' }).length &gt;= getters.currentAccount.maxApiChecks } }, </code></pre><!--kg-card-end: markdown--><p>The property <code>apiChecks</code> is dynamically generated based on two other properties in our data store:</p><ol><li><code>checks</code>, an array of all checks which we first filter on check type and then count. Add a check or remove a check and this gets updated on the fly.</li><li><code>currentAccount.maxApiChecks</code>, a property determined by the plan the user is currently on. Upgrade and you get more, automatically bumping this value.</li></ol><p>We do the exact same thing for all other volume limited resources like browser checks, team members and dashboards.</p><h2 id="example-3-plan-feature-toggle">Example 3: Plan feature toggle</h2><p>Here's what you see when your plan does not have a specific feature, in this case the Pagerduty integration which is not in our Developer plan.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.checklyhq.com/content/images/2019/03/Screen-Shot-2019-03-31-at-20.22.00.png" class="kg-image" alt="How we deal with plan limits in the front end of our SaaS app"><figcaption>Example of plan feature toggle message</figcaption></figure><!--kg-card-end: image--><p>This one looks the simplest, but I actually encountered this pattern so often I abstracted it a bit more. I expect Checkly's feature set to grow quite a bit so having a fairly generic way of dealing with this is very handy. Here's the gist:</p><!--kg-card-begin: markdown--><pre><code class="language-js">.pagerduty .header Pagerduty span(v-if='$planHasFeature(&quot;PAGERDUTY&quot;)') // Pagerduty integration settings span(v-else) feature-not-available </code></pre><!--kg-card-end: markdown--><p>There are two things going on here:</p><p>First, we check if the current plan has the feature <code>PAGERDUTY</code> enabled. Instead of using a component specific property, we use a <a href="https://vuejs.org/v2/guide/mixins.html#Global-Mixin">global mixin</a> to expose a function called <code>$planHasFeature()</code> to all templated elements.</p><p>What does this function do? Nothing more than checking the central data store if the <code>currentAccount.features</code> array holds the feature we pass into the function. The code is below.</p><!--kg-card-begin: markdown--><pre><code class="language-js">const hasFeature = { created () { this.$planHasFeature = function (feature) { return this.features.includes(feature) } }, computed: { features () { return this.$store.getters.currentAccount.features } } } </code></pre><!--kg-card-end: markdown--><p>Second, if this plan does not have this feature, we render a generic <code>feature-not-available</code> component. This is just a nice button that takes you to our upgrade page. This component is already used in nine other components, so I guess the extra abstraction was worth it.</p><p>With these patterns you can cater for a ton of common SaaS thing like showing upgrade messages and counter for volume based features. Hope it helps!</p><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><p>banner image: Kawase Hasui (1883-1957), "Seasonal flowers in Japan",  <a href="https://crowcollection.org/exhibition/news-from-abroad-japanese-woodblock-prints-from-yokohama-japan/">source</a></p>
]]>
            </content:encoded>
        </item>
        <item>
            <title>
                <![CDATA[ How we manage plans & features in our SaaS app ]]>
            </title>
            <description>
                <![CDATA[
This is how we manage what a user can do and see on their account and plan in our SaaS app. We check for feature toggles and volume limits.
]]>
            </description>
            <link>
https://blog.checklyhq.com/how-we-manage-plans-features-in-our-saas-app/
            </link>
            <guid isPermaLink="false">5c954b1feac79f00cc690262</guid>
            <category>
                <![CDATA[ building a saas ]]>
            </category>
            <category>
                <![CDATA[ development ]]>
            </category>
            <category>
                <![CDATA[ javascript ]]>
            </category>
            <dc:creator>
                <![CDATA[ Tim Nolet ]]>
            </dc:creator>
            <pubDate>Sun, 24 Mar 2019 00:44:22 GMT</pubDate>
            <media:content url="https://blog.checklyhq.com/content/images/2019/03/L2006_310_Master-1024x510.jpg" medium="image"/>
            <content:encoded>
                <![CDATA[
<img src="https://blog.checklyhq.com/content/images/2019/03/L2006_310_Master-1024x510.jpg" alt="How we manage plans & features in our SaaS app"><p>How do you deal with <strong>what a user can do on their account</strong> in a SaaS app? Can Jane on the "Starter" plan create another widget when she is near the limit of her plan? What if she's a trial user?</p><p>Turns out this is a mix of things</p><ul><li>Feature toggling</li><li>Counting stuff™</li><li>Custom API middleware very specific to your situation</li></ul><p>Like the topic of our last post in this series on <a href="https://blog.checklyhq.com/building-a-multi-tenant-saas-data-model/">creating a basic SaaS data model</a> there is a lack of clear examples on how to deal with this super common problem.</p><p>Here is how we do it at Checkly with our Node.js, Hapi.js backend. This will probably translate fine to other platforms.</p><h2 id="the-problem">The problem</h2><p>Let's make it as concrete a possible and, as the saying goes, <em> a SaaS pricing page is worth a thousand words.</em></p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://blog.checklyhq.com/content/images/2019/03/image-21.png" class="kg-image" alt="How we manage plans & features in our SaaS app"></figure><!--kg-card-end: image--><p>We have three plans with varying prices: Developer, Starter and Growth. <br>Different plans allow different volumes and different features.</p><p>In this example:</p><ul><li>The<strong> API and browser checks</strong> are volume limited. The Developer plan gets 5, the Starter plan 15, the growth plan 40.</li><li>The <strong>Team members</strong> feature is either enabled or not, and when enabled also volume limited.</li><li>The <strong>CI/CD trigger</strong> feature is either enabled or not. No volume stuff going on.</li></ul><p>Not visible in the pricing page is what happens during a trial. During our 14 day trial we do not give trial users an SSL secured public dashboard. Due to technical and abuse reasons this only kicks in when you become a paying customer.</p><p>Also, remember that paying customers might have issues with their credit card, or simply stop paying for unknown reasons. We need to catch this, but we also want to err on the side of caution to not piss off customers just having some banking issue.</p><p>Let's boil it down to four categories of "things we have to somehow enforce and keep track of" in our SaaS app. </p><ol><li><strong>Trial vs. Non-trial</strong>: Still kicking the tires or an honored member of our  little club?</li><li><strong>Paying vs. Lapsing:</strong> You used to pay us, but not anymore...</li><li><strong>Plan based feature toggles</strong>: Does your plan allow you to access this feature?</li><li><strong>Plan based volume limits</strong>: Does your plan allow you to create more of these things?</li></ol><h2 id="trial-vs-non-trial">Trial vs. Non-trial</h2><p>Every user that signs up is automatically assigned a trial plan. The data model is as shown below. Check this <a href="https://blog.checklyhq.com/building-a-multi-tenant-saas-data-model/">earlier post</a> for more details.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.checklyhq.com/content/images/2019/03/image-23.png" class="kg-image" alt="How we manage plans & features in our SaaS app"><figcaption>accounts &amp; plans data model</figcaption></figure><!--kg-card-end: image--><p>Checking this is straightforward, just do your language's variation of:</p><!--kg-card-begin: code--><pre><code>if (account.plan.name === "trial") { // do trial things }</code></pre><!--kg-card-end: code--><p>Being in a trial or not is a pretty binary and boolean friendly thing. Just make sure you switch the user to some other plan when he/she starts paying. Which brings us to... </p><h2 id="paying-vs-lapsing">Paying vs. Lapsing</h2><p>Should be easy, right? Someone signs up for a paid plan and you flip a flag from <code>paying = false</code> to <code>paying = true</code>. </p><p>But what does "paying" actually mean? And what if they stop paying?</p><p>At Checkly, "paying" means your <em>account </em>record in our Postgres database has a <em>stripe_subscription_id</em> that is not NULL and a <em>plan_expiry </em> date that is in the future. In Javascript code:</p><!--kg-card-begin: code--><pre><code>const paying = account.stripe_subscription_id != null &amp;&amp; account.plan_expiry &gt; Date.now()</code></pre><!--kg-card-end: code--><p>Both fields are set when a Stripe webhook comes in that signals a successful payment for a subscription. This automatically tracks lapsing payments and subscription cancelations. No extra code to update an arbitrary "paying" field. </p><p><strong>Takeaway</strong>: "paying" is not a boolean you update explicitly. It's a computed property depending on a bunch of fields. Take into account what a paying subscriber / account holder means in your specific context. If this is a monthly / yearly SaaS thing, you probably have more than one field of data to check.</p><h2 id="plan-based-feature-toggles">Plan based feature toggles</h2><p>To check what features a user can access based on their plan we store a set of string constants for each account in a field called <em>features</em>.  This builds on a base layer of <em>features</em> available to every subscriber. An empty list of <em>features</em> means you have the base plan. In code:</p><!--kg-card-begin: code--><pre><code>const features = ["CI_CD_TRIGGERS", "SOME_OTHER_FEATURE"]</code></pre><!--kg-card-end: code--><p>This set of <em>features</em> lives as an array field on each <em>account</em> record a user is linked with. Furthermore, this field is made available to the backend and frontend, of course only writable by the backend. No updating your own features!</p><p>This field gets populated or updated on only two occasions:</p><ol><li>A user signs up for a trial. We populate the <em>features </em>field with trial features.</li><li>A user upgrades to a paid account. We update the <em>features </em>field with features as they are in the corresponding plan.</li></ol><p>We don't have a fancy interface for managing these feature toggles. This is not some experimentation or dark launching framework.</p><p>Checkly is a Vue.js single page app backed by a Hapi.js API backend. But this works probably on any SPA or non-SPA based system.</p><p>Here's what our route to controller mapping looks like. </p><!--kg-card-begin: markdown--><pre><code class="language-js">const a = require('../../models/defaults/access-rights') const f = require('../../models/defaults/features') { method: 'POST', path: '/accounts/triggers/{checkId}', config: { plugins: { policies: [hasAccess([a.OWNER, a.ADMIN]), hasFeature(f.TRIGGERS)] }, handler: TriggerController.createTrigger } }, </code></pre><!--kg-card-end: markdown--><p>There are two interesting bits here.</p><ul><li>The <code>hasAccess</code> function that checks for user access rights.</li><li>The <code>hasFeature</code> function that checks for features.</li></ul><p>Both functions are enabled by the <a href="https://github.com/mark-bradshaw/mrhorse">mr. Horse plugin</a>, allowing for <em>policies</em> to be attached to any API route. You can also see we import the canonical list of access rights and features from a central list of defaults values.</p><p>What actually happens in the <code>hasAccess</code> and <code>hasFeature</code> functions depends heavily on what language/framework you are using. </p><p>Here are the shortened code versions of how we do it for the access rights and features. Notice they both return functions that the http router injects in the the http request cycle. </p><!--kg-card-begin: markdown--><pre><code class="language-js">const hasAccess = function (accessRights) { // Define a function to check access based on request data. // in a previous authentication step, the account data was fetched // from the database. const hasSpecificAccess = function (request, reply, next) { if (accessRights.includes(access)) { next(null, true) } else { next(null, false) } } return hasSpecificAccess } </code></pre><!--kg-card-end: markdown--><p>Checking features...</p><!--kg-card-begin: markdown--><pre><code class="language-js">const hasFeature = function (feature) { const hasSpecificFeature = function (request, reply, next) { // match if the feature is enabled return features &amp;&amp; features.includes(feature) ? next(null, true) : next(null, false) } return hasSpecificFeature } </code></pre><!--kg-card-end: markdown--><h2 id="plan-based-volume-limits">Plan based volume limits</h2><p>Checking plan <strong>features</strong> is pretty neatly handled by a fairly generic way of asserting if a thing is either "on" or "off". </p><p>Checking volumes is a bit different. Why is it different? It is different because we need to include the state of specific resources we are offering our customers, not just flags on the <em>account</em> record.</p><p>This means you have to actively poll your database and count stuff on each request. Yes, you can cache a bit and being off by one might not be the end of the world.</p><p>In the pricing page example above you can see Checkly offers 5 API checks for one plan and 15 for the other. This is how we assert this volume limit in our backend API</p><!--kg-card-begin: markdown--><pre><code class="language-javascript">function getVolumeLimits (accountId, delta) { const checksCountQuery = Checks.query().where({ accountId }).count() const accountLimitsQuery = Account.query().findOne({ accountId }) return Promise.all([checksCountQuery, accountLimitsQuery]) .then(res =&gt; { const count = res[0].count const { maxChecks } = res[1] const newTotal = parseInt(count) + delta return newTotal &lt;= maxChecks }) } </code></pre><!--kg-card-end: markdown--><ol><li>This function is executed after basic authorization, but before any actual work is done.</li><li>We fetch the current amount checks and the plan limit of checks for the current account concurrently. This is a very Javascript <code>Promise.all</code> statement.</li><li>We compare the current amount to the new total amount. In our specific case, a user can create multiple checks at once, hence the <code>delta</code> argument. In this example it is <code>1</code> but in real life it can be any number above <code>0</code>. We need to check if the total amount of new "things to be created" fits into the plan.</li><li>In the end, we return if the <code>newTotal</code> is less or equal to the <code>maxChecks</code>, our plan limit.</li></ol><p>Asserting users are within their plan limits on the backend is really important for all kinds of reasons, but how are we going to do "be nice about it" on the frontend, specifically in an SPA type setup? We don't want to have the situation where a user is happily creating a new thing, hits <em>submit</em> and is then presented with a "you are over your plan limits"-message.</p><h2 id="what-about-the-rest">What about the rest?</h2><p>What about role based access control?<br>How the hell do you handle this stuff on the front end?</p><p>Yes, all very important topics. They all weave into the stuff discussed above so we'll dive into it in the next blog post. Call to action =&gt; ✨ Subscribe now ✨</p><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><p>banner image: Unsen, "New Invention: Picture of the Interior Works of a German Battleship",  Original ca. 1874. <a href="https://crowcollection.org/exhibition/news-from-abroad-japanese-woodblock-prints-from-yokohama-japan/">source</a></p>
]]>
            </content:encoded>
        </item>
        <item>
            <title>
                <![CDATA[ Building a multi-tenant SaaS data model ]]>
            </title>
            <description>
                <![CDATA[
How we built a basic multi-tenant SaaS data model on PostgreSQL with accounts, users, plans & subscriptions.
]]>
            </description>
            <link>
https://blog.checklyhq.com/building-a-multi-tenant-saas-data-model/
            </link>
            <guid isPermaLink="false">5c8cdb60364e9d00bf9d0d34</guid>
            <category>
                <![CDATA[ building a saas ]]>
            </category>
            <category>
                <![CDATA[ sql ]]>
            </category>
            <category>
                <![CDATA[ development ]]>
            </category>
            <dc:creator>
                <![CDATA[ Tim Nolet ]]>
            </dc:creator>
            <pubDate>Sun, 17 Mar 2019 20:12:40 GMT</pubDate>
            <media:content url="https://blog.checklyhq.com/content/images/2019/03/3985273351_9a3558f164_b.jpg" medium="image"/>
            <content:encoded>
                <![CDATA[
<img src="https://blog.checklyhq.com/content/images/2019/03/3985273351_9a3558f164_b.jpg" alt="Building a multi-tenant SaaS data model"><p>This is a run down on the basic multi-tenant SaaS data model underlying <a href="https://checklyhq.com/">Checkly</a>. Users, accounts, plans, that type of stuff. When building this, I found it surprisingly hard to find any solid info in the gazillions of developer and startup blogs; most were just to vague on the implementation details.</p><h2 id="postgresql-mongo-or-dynamodb">PostgreSQL, Mongo or DynamoDB?</h2><p>Short version: Postgres. It's an absolutely fantastic piece of engineering. <br>Run it on Heroku, <em>it just works</em>™ and it makes me feel like some grizzled, elite Spetsnatz commando has my back. </p><p>Long version: In an alternative universe, I'd have implemented Checkly completely on AWS DynamoDB. The peace of mind a fully managed — web scale... — database brings you is just awesome when you want to focus on customers instead of database management.</p><p>So I actually tried getting a SaaS model into DynamoDB. That exercise was so utterly unsuccessful it actually makes me laugh now. The limitations on the primary key and range keys alone make it just a very bad fit for this use case. AWS <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-modeling-nosql-B.html">has a write up</a> on how something like this <em>could</em> actually be achieved. I have never seen a better example of "shoehorning".</p><p>MongoDB then? </p><p>This could actually have worked. Still no actual relations, but Mongo has ways of making this work. Sadly, my brain just can not get used to the MongoDB query language: I found the defacto Node.js driver Mongoose a convoluted mess, especially the documentation. Also, I knew I was going to do a ton of aggregation on metrics (averages, percentiles etc.) and Mongo’s aggregation features were/are very minimal.</p><p>DynamoDB and also MongoDB are completely valid products. Just don’t use it for anything relational(ish). Mind blown.</p><p>Also, Postgres is pretty nimble, even with terabytes of data and high read/write traffic.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.checklyhq.com/content/images/2019/03/image-8.png" class="kg-image" alt="Building a multi-tenant SaaS data model"><figcaption>Postgres' aggregation and memory usage are the best in class. It is also consistently in the top 3 in this benchmark on other workloads <a href="https://www.arangodb.com/wp-content/uploads/2018/02/UPDATE-Benchmark-2018.001.jpeg">https://www.arangodb.com/wp-content/uploads/2018/02/UPDATE-Benchmark-2018.001.jpeg</a></figcaption></figure><!--kg-card-end: image--><p>So Postgres it was. Onwards!</p><h2 id="single-multi-tenant-database">Single, multi-tenant database</h2><p>Short interlude before we dive into the actual data model. How do we handle the partitioning of customers at the very highest implementation level now that we have chosen Postgres?</p><p>There are a couple of options out there:</p><ol><li><strong>One tenant, one database: </strong>Each tenant its own database instance. 100% separation.  If you expect either very high security requirements from customers or expect the need to scale out parts of your platform for specific customers, think Salesforce like size.</li><li><strong>One database, schema per customer:</strong> A single database, with a separate schema for each customer. Duplicating tables for each schema. This can make migrating especially heavy users to higher spec machines easy. It also is even more secure as you leverage the built-in security model of your DBMS.</li><li><strong>One database, one schema</strong>: Just one schema that holds all the tables and an “account ID” for each tenant. This is the model we chose for Checkly, as all of the above concerns are/were not applicable to Checkly. The expected usage patterns and storage needs are also not that massive</li></ol><h2 id="accounts-users">Accounts &amp; users</h2><p>Checkly and many other typical B2B focused SaaS are structured as follows:</p><ol><li>Users belong to an account, also sometimes called an organization.</li><li>An account can have multiple users and users can switch between multiple accounts. This is specifically interesting if offering a product aimed at agencies or larger organizations where one customer can actually "own" multiple accounts.</li><li>Accounts have settings, preferences and resources associated with it. They apply to each user linked to that account.</li><li>Users can set personal preferences per linked account.</li><li>Users can have specific access rights per account.</li></ol><p>To achieve this, we use the following data schema:</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://blog.checklyhq.com/content/images/2019/03/image-12.png" class="kg-image" alt="Building a multi-tenant SaaS data model"></figure><!--kg-card-end: image--><p>Let's go over each table and point out what's interesting:</p><h3 id="1-users">1. Users</h3><p>The <em>users</em> table is quite straightforward. It holds the basic details we gather either from social login (Google &amp; Github in our case) or from email signup. Notice there is no password field. We use <a href="https://auth0.com">Auth</a>0 for that.</p><h3 id="2-memberships">2. Memberships</h3><p>The <em>memberships </em>table models the many-to-many relation between users and their accounts. The most important bits are:</p><ol><li><strong>Access control:</strong> The <em>access </em>field is an enum that holds one of the possible user roles as a string constant, i.e: READ_ONLY, READ_WRITE, ADMIN or OWNER. The actual enforcement of these roles is done in the API but that's a story for another time.</li><li><strong>Per-account user preferences</strong>: The <em>receive_weekly_summary </em>field is an example of a specific setting the user might want to toggle per account. </li></ol><h3 id="3-accounts">3. Accounts</h3><p>This is where the meat is. The primary key of the <em>accounts </em>table is referenced as a foreign key in many, many other tables. Invoices, dashboards, team invites, etc. all reference the <em>accounts</em> table.</p><p>Besides being the root for almost all resources in the whole application, the <em>accounts</em> table has three main functions:</p><ol><li><strong>Subscription &amp; billing cycles: </strong>we need to keep track if payments are made in some way. In the example you can see the <em>stripe_customer_id, stripe_subscription_id </em>and the <em>current_period_ends </em>fields.<br><br>When a user signs up for a paid plan, we use <a href="https://stripe.com/docs/webhooks">Stripe</a> webhooks to fill these fields. On each subsequent billing cycle our API receives another webhook call and we bump the <em>current_period_ends </em>date field. <br><br>Notice that if for any reason no money comes in, the date is never bumped. The rest of our code uses this field to check whether it should allow users to keep interacting with the product and whether it should do background jobs.</li><li><strong>Plan limits: </strong>Each plan customers can subscribe to has volume limits associated with them. In our case these are things like amount of checks, amount of team mates, SMS messages sent per month. The upper limits for this are recorded in field like <em>max_api_checks</em> from the example. <br>These limits get set when subscribing and when changing to a higher/lower plan. More on that below.</li><li><strong>Plan feature toggles: </strong>Plans can also have non-volume based differences. For example, people on our Developer plan do not have access to <a href="https://checklyhq.com/docs/api-checks/setup-teardown-scripts/">Setup &amp; Teardown</a> scripts. These are essentially feature toggles based on what plan you subscribe to.<br><br>To model this, we use the <em>features </em>field which is of the String Array type, a pretty nice feature in Postgres. It holds a set of string constants like SMS_ALERTS, SETUP_TEARDOWN and PROMETHEUS. Each constant is associated with a feature and we use them to  enforce the limits in the API on the backend and show a nice hint to the user that a feature is only available after upgrading.</li></ol><!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.checklyhq.com/content/images/2019/03/image-11.png" class="kg-image" alt="Building a multi-tenant SaaS data model"><figcaption>Show the upgrade button when a feature is not in the feature array</figcaption></figure><!--kg-card-end: image--><blockquote>Funky tip 👉 We actually bump  the <em>current_period_ends</em> date + some extra grace days. Would suck if the monitoring is down due to annoying but benign some card issue.</blockquote><h2 id="on-plans-subscriptions">On plans &amp; subscriptions</h2><p>This might seem unintuitive, but there is a very weak relation between the <em>plans</em> table and the <em>accounts </em>table — you might have noticed the duplication of the <em>max_api_checks </em>and the <em>features </em>fields in each table.</p><p>Both these fields describe plan limits and we actively copy values from the <em>plans</em> table to the <em>accounts</em> table when an account is created. This makes tweaking specific customer requests a lot easier. </p><p>Want a custom plan that has slightly more API checks? We can do that. Just update the specific account row and adjust the monthly price in Stripe. Want to give access to a new feature to a small set of users? Just update the <em>features </em>array for just those account. Later roll it out to all customers. Who needs a complicated feature toggling framework?</p><p>So what actually is a subscription in this context? Good question, as it has no direct representation in this model. In the most literal sense, it is the <em>invoice.payment_succeeded </em>Stripe webhook coming in and telling us customer ID X with subscription ID Y has just paid. </p><p>Everything else is decoupled: the actual price per month / per year, the billing interval, what features you get and what volume limits apply. This decoupling then allows you to experiment more with price and the exact composition of your plans. Actually, the whole Checkly application has no "knowledge" of the pricing except for some markup on the https://checklyhq.com/pricing page.</p><!--kg-card-begin: hr--><hr><!--kg-card-end: hr-->
]]>
            </content:encoded>
        </item>
        <item>
            <title>
                <![CDATA[
Announcing: Threshold Alerting and Expanded Locations
]]>
            </title>
            <description>
                <![CDATA[
We’re super happy to announce some big upgrades to Checkly’s alerting features for 2019 🎉
]]>
            </description>
            <link>
https://blog.checklyhq.com/announcing-threshold-alerting-and-expanded-locations/
            </link>
            <guid isPermaLink="false">5c89201f167d1600cc2a1a5f</guid>
            <category>
                <![CDATA[ product ]]>
            </category>
            <category>
                <![CDATA[ announcements ]]>
            </category>
            <dc:creator>
                <![CDATA[ Tim Nolet ]]>
            </dc:creator>
            <pubDate>Thu, 10 Jan 2019 15:22:00 GMT</pubDate>
            <content:encoded>
                <![CDATA[
<!--kg-card-begin: image--><figure class="kg-card kg-image-card kg-width-full"><img src="https://blog.checklyhq.com/content/images/2019/03/image-4.png" class="kg-image"></figure><!--kg-card-end: image--><p>We’re super happy to announce some big upgrades to Checkly’s alerting features for 2019 🎉. We listened to what our customers were missing alerting wise and what parts we could polish and upgrade. Two things popped up again and again:</p><ol><li>Checkly should give you more control over when and how often you are alerted.</li><li>Data center locations were not covering all customer areas (Korea, France, Nordics etc.)</li></ol><p>This update should go a long way in addressing these needs.</p><h2 id="1-take-control-with-threshold-alerting-and-reminders">1. Take control with threshold alerting and reminders</h2><p>The internet can be flaky. Good services or apps sometimes do weird things just once. You might not want to be alerted <em>all the time</em>. On the other hand, some services are extremely critical, so you welcome some reminders when things are looking bad.</p><p>With Checkly’s new threshold based alerting you can now:</p><ul><li>Get an alert of on the second or third failure.</li><li>Get an alert after 5 minutes of failures.</li><li>Get one or more reminders after a failure is triggered.</li></ul><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://checklyhq.com/blog/alert-settings.cdb551de.png" class="kg-image" alt="alert settings"></figure><!--kg-card-end: image--><p>You can tweak these settings at the global account level, or per check. <a href="https://checklyhq.com/docs/alerting/">Learn more about alerting</a></p><h2 id="2-more-locations-">2. More locations!</h2><p>We recently re-architected a part of our infrastructure, enabling us to hook up all of the AWS regions where the Lambda service is available: Stockholm 🇸🇪, Seoul 🇰🇷 and Paris 🇫🇷 here we come!</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://checklyhq.com/blog/datacenter-locations.7e32e377.png" class="kg-image" alt="data center locations"></figure><!--kg-card-end: image--><p>As of today you can select up to eight data center locations for API checks and four for Browser checks from the total of sixteen locations. Moreover, we commit to adding new regions as AWS makes them available like Milan (Italy), Cape Town (South Africa) and Bahrain.</p><p>– Tim from Checkly</p>
]]>
            </content:encoded>
        </item>
        <item>
            <title>
                <![CDATA[ Node.js API and Web Frameworks for 2019 ]]>
            </title>
            <description>
                <![CDATA[
A Node.js API and web framework comparison for 2019 with categories on sponsorship, donations, Github stars and NPM audit vulnerabilities.
]]>
            </description>
            <link>
https://blog.checklyhq.com/node-js-api-and-web-frameworks-for-2019/
            </link>
            <guid isPermaLink="false">5c8913f3167d1600cc2a1a03</guid>
            <category>
                <![CDATA[ javascript ]]>
            </category>
            <category>
                <![CDATA[ development ]]>
            </category>
            <dc:creator>
                <![CDATA[ Tim Nolet ]]>
            </dc:creator>
            <pubDate>Mon, 10 Dec 2018 14:30:00 GMT</pubDate>
            <media:content url="https://blog.checklyhq.com/content/images/2019/03/newyear1.e2e04fa4.jpg" medium="image"/>
            <content:encoded>
                <![CDATA[
<img src="https://blog.checklyhq.com/content/images/2019/03/newyear1.e2e04fa4.jpg" alt="Node.js API and Web Frameworks for 2019"><p>2018 was an interesting year for Node.js frameworks and open source software in general. Developer communities discussed the role of corporate sponsorship and how to ma
]]>
                <![CDATA[
intain a project used by millions but not supported financially.</p><p>Similarly, security concerns were top of mind with some popular Node / JS packages <a href="https://github.com/bitpay/copay/issues/9346">being hijacked</a> and <a href="https://blog.github.com/2017-11-16-introducing-security-alerts-on-github/">Github launching their security alerts feature</a> for projects hosted on their site.</p><p>That is why in this Node.js framework roundup we have categories on <strong>sponsorship</strong>, <strong>donations</strong> and <strong>NPM audit vulnerabilities</strong> to give better insight into how each of the frameworks listed tackles these issues. Frameworks are evaluated alphabetically.</p><h2 id="charts-graphs">Charts &amp; graphs</h2><h3 id="github-stars">Github stars</h3><p>Sails, Koa and Express are clearly head and shoulders above the rest with regard to Github stars. But the total amount of stars is maybe not the clearest indicator of relevancy in 2019. For that we need to look at the growth.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://blog.checklyhq.com/content/images/2019/03/github.svg" class="kg-image" alt="Node.js API and Web Frameworks for 2019"></figure><!--kg-card-end: image--><h3 id="github-stars-growth-in-2018">Github stars growth in 2018</h3><p>The explosive growth of Nest becomes very clear when we track the growth of Github stars over 2018. The y-axis is the percentage of growth from roughly the start of January 2018 up till mid-December 2018. The number is a fairly good approximation, but the raw data is a bit hard to come by. Interestingly Sails and Express have almost flat lined in comparison, but that could also be due to market saturation: only so many people out there interested in giving Github stars to Node.js frameworks.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://blog.checklyhq.com/content/images/2019/03/github-1.svg" class="kg-image" alt="Node.js API and Web Frameworks for 2019"></figure><!--kg-card-end: image--><h3 id="dependencies">Dependencies</h3><p>Node and its NPM package management solution gets a bad wrap for pulling in (transitive) dependencies. In this light, Nest seems fairly lean where Sails has almost four times the direct dependencies.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://blog.checklyhq.com/content/images/2019/03/github-3.svg" class="kg-image" alt="Node.js API and Web Frameworks for 2019"></figure><!--kg-card-end: image--><h3 id="weekly-npm-downloads">Weekly NPM downloads</h3><p>I had to re-check the data on the NPM site for this. Express completely dwarves the amount of downloads of any of its competitors. Only Koa and Hapi register on this graph as tiny slivers of color. Of course, some frameworks use Express under the hood, i.e. Sails and Nest.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://blog.checklyhq.com/content/images/2019/03/github-4.svg" class="kg-image" alt="Node.js API and Web Frameworks for 2019"></figure><!--kg-card-end: image--><h2 id="choosing-a-node-js-framework">Choosing a Node.js framework</h2><p>Each framework has its goals, design decisions and peculiarities. You should carefully consider how these map to your own use case currently and as far as you can tell in the future.</p><p>Sometimes, this is very clear:</p><blockquote>“We need a full web app, with HTML templating, database models, authentication, API integrations, mailing etc.”</blockquote><p>We mark these as <strong>Full Stack</strong> in this article. A completely different use case would be:</p><blockquote>“We need a back end API endpoint that ingests IOT data as small JSON messages.”</blockquote><p>We mark these as <strong>API</strong>. Of course, your use case might be somewhere in between. In this case you need a framework that can start small, but can grow in complexity and functionality with either plugins or middlewares. We mark these as <strong>Minimal</strong> as in the core is small, but the eco-system provides modules to grow the range of features.</p><p>It speaks for many of the frameworks listed here that all of them can be coaxed into any of the roles on the spectrum. Some come with supported, first party modules to extent the core, others rely more on community supplied extensions.</p><h2 id="adonisjs">AdonisJs</h2><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://avatars2.githubusercontent.com/u/13810373?s=100&amp;v=4" class="kg-image" alt="Node.js API and Web Frameworks for 2019"></figure><!--kg-card-end: image--><p><a href="https://adonisjs.com/">AdonisJs</a> takes a page from the Hapi manual by explicitly choosing to write its own dependencies from scratch. This means the AdonisJS eco system comes with a set of specific modules that neatly slot into the core framework. This also means that for instance the test runner or template engines are probably new to most users, although you can still use other runners or templating engines of course.</p><p>AdonisJs was started in 2016 and is aimed at full stack usage: HTTP request routing, templating, authentication and database ORM are all available out of the box.</p><p>In the community, AdonisJs is often compared to PHP’s Laravel although this can be said of any framework using implementing MVC patterns.</p><!--kg-card-begin: markdown--><table><thead><tr><th><a href="https://adonisjs.com/">https://adonisjs.com/</a></th><th></th></tr></thead><tbody><tr><td><strong>Version</strong></td><td>5.0.12</td></tr><tr><td><strong>Github stars</strong></td><td>5195 / up ~60% in 2018</td></tr><tr><td><strong>Dependencies</strong></td><td>24</td></tr><tr><td><strong>Weekly downloads</strong></td><td>5896</td></tr><tr><td><strong>ORM</strong></td><td>Lucid, Knex.js based</td></tr><tr><td><strong>Async/Await</strong></td><td>Yes</td></tr><tr><td><strong>License</strong></td><td>MIT</td></tr><tr><td><strong>Corporate sponsorship</strong></td><td><a href="https://scotch.io">Scotch.io</a>, <a href="https://www.keycdn.com/">KeyCDN</a></td></tr><tr><td><strong>Donations</strong></td><td><a href="https://www.patreon.com/adonisframework">https://www.patreon.com/adonisframework</a></td></tr><tr><td><strong>NPM audit</strong></td><td>0</td></tr><tr><td><strong>File under</strong></td><td>Full stack, Laravel</td></tr></tbody></table><!--kg-card-end: markdown--><h2 id="express">Express</h2><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://avatars1.githubusercontent.com/u/5658226?s=100&amp;v=4" class="kg-image" alt="Node.js API and Web Frameworks for 2019"></figure><!--kg-card-end: image--><p><a href="http://expressjs.com/">The grandaddy</a> of Node.JS API frameworks. It is still a very minimal framework that, on install, gives you a bare bones API server. Extra functionality is added using one of the many middleware projects available. Some of which, like <a href="http://www.passportjs.org/">Passportjs</a>, have come to be standards in themselves.</p><p>Due to its minimal footprint, frameworks like Sails.js and Nest use Express as a base application layer and extend it with extra, opinionated features.</p><!--kg-card-begin: markdown--><table><thead><tr><th><a href="http://expressjs.com/">http://expressjs.com/</a></th><th></th></tr></thead><tbody><tr><td><strong>Version</strong></td><td>4.16.4</td></tr><tr><td><strong>Github stars</strong></td><td>41.417 / up ~18% in 2018</td></tr><tr><td><strong>Dependencies</strong></td><td>30</td></tr><tr><td><strong>Weekly downloads</strong></td><td>7.170.825</td></tr><tr><td><strong>ORM</strong></td><td>BYO / plugins</td></tr><tr><td><strong>Async/Await</strong></td><td>No</td></tr><tr><td><strong>License</strong></td><td>MIT</td></tr><tr><td><strong>Corporate sponsorship</strong></td><td><a href="https://strongloop.com/">Strongloop / IBM</a></td></tr><tr><td><strong>Donations</strong></td><td>-</td></tr><tr><td><strong>NPM audit</strong></td><td>0</td></tr><tr><td><strong>File under</strong></td><td>Minimal</td></tr></tbody></table><!--kg-card-end: markdown--><h2 id="fastify">Fastify</h2><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://avatars2.githubusercontent.com/u/24939410?s=100&amp;v=4" class="kg-image" alt="Node.js API and Web Frameworks for 2019"></figure><!--kg-card-end: image--><p><a href="https://www.fastify.io/">Fastify</a> is an API framework 100% aimed at performance. Claiming to be inspired by Hapi and Express, the maintainers have chosen to focus on balancing developer experience with raw speed and performance.</p><p>Although Fastify is again a very minimal framework, the middleware architecture is compatible with Express and Restify middlewares, greatly expanding possible use cases.</p><p>Fastify comes with experimental HTTP 2.0 support and ships with TypeScript typings.</p><!--kg-card-begin: markdown--><table><thead><tr><th><a href="https://www.fastify.io/">https://www.fastify.io/</a></th><th></th></tr></thead><tbody><tr><td><strong>Version</strong></td><td>1.13.1</td></tr><tr><td><strong>Github stars</strong></td><td>8.901 / up ~60% in 2018</td></tr><tr><td><strong>Dependencies</strong></td><td>13</td></tr><tr><td><strong>Weekly downloads</strong></td><td>15.335</td></tr><tr><td><strong>ORM</strong></td><td>BYO / plugins</td></tr><tr><td><strong>Async/Await</strong></td><td>Yes</td></tr><tr><td><strong>License</strong></td><td>MIT</td></tr><tr><td><strong>Corporate sponsorship</strong></td><td><a href="https://www.nearform.com/">Nearform</a></td></tr><tr><td><strong>Donations</strong></td><td>-</td></tr><tr><td><strong>NPM audit</strong></td><td>0</td></tr><tr><td><strong>File under</strong></td><td>Minimal, Performance</td></tr></tbody></table><!--kg-card-end: markdown--><h2 id="hapi">Hapi</h2><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://avatars1.githubusercontent.com/u/3774533?s=100&amp;v=4" class="kg-image" alt="Node.js API and Web Frameworks for 2019"></figure><!--kg-card-end: image--><p><a href="https://hapijs.com/">Hapi</a> was developed at Walmart to provide a rock solid foundation for their e-commerce business. Now spun out as open source framework with no ties to its originating company, Hapi remains popular for larger.</p><p>Hapi comes with a large set of separate, but tightly integrated and supported plugins for features like logging, templating, caching, error handling etc. It’s object validation plugin <a href="https://github.com/hapijs/joi">Joi</a> is almost as popular as the framework itself.</p><p>In the community, Hapi is praised for its API, its robustness and reliability. Also, Hapi does not have any external code dependencies making security issues much more controllable.</p><p>Version 17.x is a ground up rewrite leveraging ES6 and ES7 features throughout the whole stack.</p><!--kg-card-begin: markdown--><table><thead><tr><th><a href="https://hapijs.com/">https://hapijs.com/</a></th><th></th></tr></thead><tbody><tr><td><strong>Version</strong></td><td>17.8.1</td></tr><tr><td><strong>Github stars</strong></td><td>10.485 / up ~19% in 2018</td></tr><tr><td><strong>Dependencies</strong></td><td>18</td></tr><tr><td><strong>Weekly downloads</strong></td><td>219.046</td></tr><tr><td><strong>ORM</strong></td><td>BYO / Plugins.</td></tr><tr><td><strong>Async/Await</strong></td><td>Yes</td></tr><tr><td><strong>License</strong></td><td>Custom</td></tr><tr><td><strong>Corporate sponsorship</strong></td><td>Auth0</td></tr><tr><td><strong>Donations</strong></td><td><a href="https://www.patreon.com/eranhammer/overview">https://www.patreon.com/eranhammer/overview</a></td></tr><tr><td><strong>NPM audit</strong></td><td>0</td></tr><tr><td><strong>File under</strong></td><td>Minimal, API, Resilience</td></tr></tbody></table><!--kg-card-end: markdown--><h2 id="koa">Koa</h2><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://avatars2.githubusercontent.com/u/5055057?s=100&amp;v=4" class="kg-image" alt="Node.js API and Web Frameworks for 2019"></figure><!--kg-card-end: image--><p><a href="https://koajs.com/">Koa</a> comes from the same people as Express, but was explicitly written to leverage new Javascript language features such as <code>async/await</code>. The Koa framework is even more minimal than Express; even routing is not included in the base install.</p><p>Koa was one of the first API frameworks to leverage ES6 and ES7 features explicitly. This shows as the documentation mentions using Babel for older Node.js versions.</p><p>Koa comes with a list of third party middlewares almost as long as Express although a lot of them seem to be abandoned or just not maintained on a regular basis.</p><!--kg-card-begin: markdown--><table><thead><tr><th><a href="https://koajs.com/">https://koajs.com/</a></th><th></th></tr></thead><tbody><tr><td><strong>Version</strong></td><td>2.6.2</td></tr><tr><td><strong>Github stars</strong></td><td>24.170 / up ~27% in 2018</td></tr><tr><td><strong>Dependencies</strong></td><td>24</td></tr><tr><td><strong>Weekly downloads</strong></td><td>275.369</td></tr><tr><td><strong>ORM</strong></td><td>BYO / plugins</td></tr><tr><td><strong>Async/Await</strong></td><td>Yes</td></tr><tr><td><strong>License</strong></td><td>MIT</td></tr><tr><td><strong>Corporate sponsorship</strong></td><td>duohui.cn</td></tr><tr><td><strong>Donations</strong></td><td><a href="https://opencollective.com/koajs">https://opencollective.com/koajs</a></td></tr><tr><td><strong>NPM audit</strong></td><td>0</td></tr><tr><td><strong>File under</strong></td><td>Minimal, ES7</td></tr></tbody></table><!--kg-card-end: markdown--><h2 id="nest">Nest</h2><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://avatars1.githubusercontent.com/u/28507035?s=100&amp;v=4" class="kg-image" alt="Node.js API and Web Frameworks for 2019"></figure><!--kg-card-end: image--><p><a href="https://nestjs.com/">Nest</a> burst onto the scene in 2017 and made a huge leap in popularity in 2018 (at least according to Github stars). Nest is a bit different than all the others as it is based on TypeScript and uses Express under the hood. Nest does work with “normal” Javascript, but the maintainers actively encourage using TypeScript.</p><p>Another twist is that Nest comes with a built-in GraphQL adapter that leverages the popular Apollo framework, although there are recipes available for more traditional ORMs and databases such Mongo using Mongoose or MySQL/Postgres using TypeORM.</p><p>2018 was a good year for Nest and we’re excited to see what 2019 brings.</p><!--kg-card-begin: markdown--><table><thead><tr><th><a href="https://nestjs.com/">https://nestjs.com/</a></th><th></th></tr></thead><tbody><tr><td><strong>Version</strong></td><td>5.5.0</td></tr><tr><td><strong>Github stars</strong></td><td>10.732 / up 280% in 2018</td></tr><tr><td><strong>Dependencies</strong></td><td>10</td></tr><tr><td><strong>Weekly downloads</strong></td><td>61.907</td></tr><tr><td><strong>ORM</strong></td><td>TypeORM</td></tr><tr><td><strong>Async/Await</strong></td><td>Yes</td></tr><tr><td><strong>License</strong></td><td>MIT</td></tr><tr><td><strong>Corporate sponsorship</strong></td><td>Valor</td></tr><tr><td><strong>Donations</strong></td><td><a href="https://opencollective.com/nest/donate">https://opencollective.com/nest/donate</a></td></tr><tr><td><strong>NPM audit</strong></td><td>0</td></tr><tr><td><strong>Notes</strong></td><td>@nest/core shows donations balance on NPM install</td></tr><tr><td><strong>File under</strong></td><td>Express-based, Typescript, GraphQL</td></tr></tbody></table><!--kg-card-end: markdown--><h2 id="restify">Restify</h2><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://avatars1.githubusercontent.com/u/6948699?s=100&amp;v=4" class="kg-image" alt="Node.js API and Web Frameworks for 2019"></figure><!--kg-card-end: image--><p><a href="http://restify.com/">Restify</a> is squarely aimed at providing a framework for building RESTful APIs, where other frameworks tend to solve API, static content and template parsing problems. It is used in production by NPM, Netflix, Joyent and Pinterest.</p><p>This focus translates into its documentation and guides. They are simple and to the point. Extensions are build using the plugin API, although the third party plugins are spread very thin.</p><p>Stressing debuggability as one of its main pilllars, it is cool to see that Restify includes automatic generation of Dtrace probes, a feature not commonly found in any of the other frameworks.</p><p></p><!--kg-card-begin: markdown--><table><thead><tr><th><a href="http://restify.com/">http://restify.com/</a></th><th></th></tr></thead><tbody><tr><td><strong>Version</strong></td><td>7.3.0</td></tr><tr><td><strong>Github stars</strong></td><td>8.857 / up ~24% in 2018</td></tr><tr><td><strong>Dependencies</strong></td><td>22</td></tr><tr><td><strong>Weekly downloads</strong></td><td>101.211</td></tr><tr><td><strong>ORM</strong></td><td>BYO / plugins</td></tr><tr><td><strong>Async/Await</strong></td><td>No</td></tr><tr><td><strong>License</strong></td><td>MIT</td></tr><tr><td><strong>Corporate sponsorship</strong></td><td>-</td></tr><tr><td><strong>Donations</strong></td><td>-</td></tr><tr><td><strong>NPM audit</strong></td><td>0</td></tr><tr><td><strong>File under</strong></td><td>Minimal, API</td></tr></tbody></table><!--kg-card-end: markdown--><h2 id="sails">Sails</h2><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://checklyhq.com/blog/sailsjs.ce013a72.png" class="kg-image" alt="Node.js API and Web Frameworks for 2019"></figure><!--kg-card-end: image--><p><a href="https://sailsjs.com/">Sails</a> was arguably the first Node.js web framework to provide a “full stack” experience similar to Rails on the Ruby platform; hence the name. It provides an opinionated MVC framework and matching stack of technologies to tackle most business-type scenarios.</p><p>This means you can set up a CRUD app very quickly due the configuration-over-code principle and the sane defaults chosen by the developer. Similar to Rails, Sails has scaffold generators to create API endpoints based on objects / entities. Sails comes with its own Waterline ORM which can front multiple database types like Postgres, MongoDB and even Redis.</p><p>Originated at the Balderdashy company, they have now renamed to “the Sails Company” and provide enterprise support.</p><!--kg-card-begin: markdown--><table><thead><tr><th><a href="https://sailsjs.com/">https://sailsjs.com/</a></th><th></th></tr></thead><tbody><tr><td><strong>Version</strong></td><td>1.1.0</td></tr><tr><td><strong>Github stars</strong></td><td>19.976 / up ~14% in 2018</td></tr><tr><td><strong>Dependencies</strong></td><td>44</td></tr><tr><td><strong>Weekly downloads</strong></td><td>23.742</td></tr><tr><td><strong>ORM</strong></td><td>Waterline.</td></tr><tr><td><strong>Async/Await</strong></td><td>Yes</td></tr><tr><td><strong>License</strong></td><td>MIT</td></tr><tr><td><strong>Corporate sponsorship</strong></td><td>Sails company</td></tr><tr><td><strong>Donations</strong></td><td></td></tr><tr><td><strong>NPM audit</strong></td><td>23 low / 2 critical</td></tr><tr><td><strong>Notes</strong></td><td>Has enterprise support</td></tr><tr><td><strong>File under</strong></td><td>Full stack, Rails, Express-based</td></tr></tbody></table><!--kg-card-end: markdown--><h2 id="server-js">Server.js</h2><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://serverjs.io/img/logo.svg" class="kg-image" alt="Node.js API and Web Frameworks for 2019"></figure><!--kg-card-end: image--><p><a href="https://serverjs.io/">Server.js</a> started in 2017 and has seen steady, but not explosive growth over 2018. Being this new, Server.js uses modern ES2016 and ES2017 language features throughout. Every install comes with batteries included: file serving, websockets, CSRF, SSL etc. Even storing sessions in a Redis store is available by default.</p><p>Because Server.js is also based on Express, you can use Express middlewares to extend its functionality.</p><p>Next to having a great NPM package name, Server.js looks very promising as light weight but stilly pretty full stack API and web framework.</p><!--kg-card-begin: markdown--><table><thead><tr><th><a href="https://serverjs.io/">https://serverjs.io/</a></th><th></th></tr></thead><tbody><tr><td><strong>Version</strong></td><td>1.0.8</td></tr><tr><td><strong>Github stars</strong></td><td>3.229 / up ~15% in 2018</td></tr><tr><td><strong>Dependencies</strong></td><td>22</td></tr><tr><td><strong>Weekly downloads</strong></td><td>1.559</td></tr><tr><td><strong>ORM</strong></td><td>BYO / plugins</td></tr><tr><td><strong>Async/Await</strong></td><td>Yes</td></tr><tr><td><strong>License</strong></td><td>MIT</td></tr><tr><td><strong>Corporate sponsorship</strong></td><td>Auth0</td></tr><tr><td><strong>Donations</strong></td><td><a href="https://www.paypal.me/franciscopresencia/">https://www.paypal.me/franciscopresencia/</a></td></tr><tr><td><strong>NPM audit</strong></td><td>0</td></tr><tr><td><strong>File under</strong></td><td>Full stack, Express-based, ES7</td></tr></tbody></table><!--kg-card-end: markdown--><h3 id="on-the-metrics-used">On the metrics used</h3><!--kg-card-begin: markdown--><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>Version</strong></td><td>The version used for checking vulnerabilities &amp; dependencies</td></tr><tr><td><strong>Github stars</strong></td><td>Stars as of 10-12-2018 compared to roughly 01-01-2018</td></tr><tr><td><strong>Dependencies</strong></td><td>Number of direct dependencies listed on NPM</td></tr><tr><td><strong>Weekly downloads</strong></td><td>umber of weekly downloads listed on NPM</td></tr><tr><td><strong>ORM</strong></td><td>Does the framework have a directly supported / native ORM</td></tr><tr><td><strong>Async/Await</strong></td><td>Does the framework natively support async/await</td></tr><tr><td><strong>License</strong></td><td>The License as shown on Github</td></tr><tr><td><strong>Corporate sponsorship</strong></td><td>Companies listed as current sponsor</td></tr><tr><td><strong>Donations</strong></td><td>Donations page</td></tr><tr><td><strong>NPM audit</strong></td><td>Number vulnerabilities listed by the <code>npm audit</code> command</td></tr><tr><td><strong>Notes</strong></td><td>Any extra notes</td></tr><tr><td><strong>File under</strong></td><td>Free form tags that try to categories the framework</td></tr></tbody></table><!--kg-card-end: markdown--><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><p><em>banner image: “Sunrise on New Year’s Day at Susaki” by Utagawa Hiroshige (1853) - <a href="https://www.mfa.org/collections/object/sunrise-on-new-years-day-at-susaki-susaki-hatsu-hinode-from-the-series-famous-places-in-edo-edo-meisho-202200">Museum of Fine Arts Boston</a></em></p>
]]>
            </content:encoded>
        </item>
        <item>
            <title>
                <![CDATA[
An in-depth look at 100% Zero Downtime deployments with Terraform
]]>
            </title>
            <description>
                <![CDATA[
How we make Hashicorp Terraform zero downtime upgrades work in real life™ on AWS EC2. Configuration, code examples, context & workflow.
]]>
            </description>
            <link>
https://blog.checklyhq.com/an-in-depth-look-at-100-zero-downtime-deployments-with-terraform/
            </link>
            <guid isPermaLink="false">5c891179167d1600cc2a19cf</guid>
            <category>
                <![CDATA[ devops ]]>
            </category>
            <category>
                <![CDATA[ terraform ]]>
            </category>
            <dc:creator>
                <![CDATA[ Tim Nolet ]]>
            </dc:creator>
            <pubDate>Sat, 03 Nov 2018 14:19:00 GMT</pubDate>
            <media:content url="https://blog.checklyhq.com/content/images/2019/03/sailing_boat.071e3a24.jpg" medium="image"/>
            <content:encoded>
                <![CDATA[
<blockquote>Update 13-03-2019: We moved our browser Checks to AWS Lambda! There will be a new write up!</blockquote><img src="https://blog.checklyhq.com/content/images/2019/03/sailing_boat.071e3a24.jpg" alt="An in-depth look at 100% Zero Downtime deployments with Terraform"><p>At Checkly, we run our <a href="https://checklyhq.com/docs/browser-checks/quickstart/">browser checks</a> on AWS EC2 instances managed by Terraform. When shipping a new version, we don’t want to interrupt our service, so we need zero downtime deployments. Hashicorp has <a href="https://www.hashicorp.com/blog/zero-downtime-updates-with-terraform">their own write up</a> on zero downtime upgrades, but it only introduces the Terraform configuration without any context, workflow or other details that are needed to actually make this work in real life™.</p><p>This is the full lowdown on how we do it in production for ~1.5 million Chrome-based browser checks since launch.</p><!--kg-card-begin: markdown--><ol><li><a href="#the-problem-s-">The Problems</a></li><li><a href="#the-architecture">The Architecture</a></li><li><a href="#terraform-modules-and-config">Terraform modules and config</a></li><li><a href="#deployment-workflow">Deployment workflow</a></li><li><a href="#monitoring">Monitoring</a></li><li><a href="#conclusions">Conclusions</a></li></ol><!--kg-card-end: markdown--><h2 id="the-problem-s-">The problem(s)</h2><p>For those less initiated into “infra structure as code” and “immutable infrastructure” let’s look at the problem a bit closer. You will see that you have to build your app in a specific way and have some specific middleware (i.e. queues) in place to benefit from this approach. Skip this if you are a grizzled veteran.</p><p>You can chop this problem into a bunch of parts. Some are Terraform related, some are not, but they all need to be in place before you can pull this off without annoying your users.</p><p>For Checkly, the app in question can be defined as a “worker”. The workers processes incoming requests based on a queue of work. More on this in the <a href="https://checklyhq.com/blog/2018/08/an-in-depth-look-at-100-zero-downtime-deployments-with-terraform/#architecture">architecture</a> section. For now, let’s look at we want of our worker and of our worker deployment process:</p><p><strong>Architecture problems</strong></p><ol><li>Workers should be “killable” without impacting user experience.</li><li>Workers of multiple versions should be able to coexist.</li><li>Workers should be upgradable independently.</li></ol><p><strong>Deployment problems (solved by Terraform)</strong></p><ol><li>New workers should start receiving production work as soon as they are ready.</li><li>Old workers should be terminated only when new workers are up and receiving work.</li><li>Botched releases should stop the roll out.</li><li>It should work over multiple AWS regions.</li></ol><p><strong>Operations problems</strong></p><ol><li>New workers should join any monitoring pool you have automatically.</li><li>Botched releases should trigger alerts.</li></ol><p>Some of these problems should be addressed during the roll out, where other should be addressed in your application architecture.</p><h2 id="the-architecture">The architecture</h2><p>Some of the problems raised above can be tackled by following a typical fan-out / fan-in pattern or a master / worker pattern. This works especially well for the Checkly use-case because users do not interact directly with the workers.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://checklyhq.com/blog/fanout.35658522.png" class="kg-image" alt="An in-depth look at 100% Zero Downtime deployments with Terraform"></figure><!--kg-card-end: image--><p>In Checkly’s case, the architecture is as follows:</p><ol><li>A cron process pushes a check to an SQS queue. Each check is a JSON formatted message and represents one run for one check in a customer’s account.</li><li>Workers subscribe to a queue. There are 5 active workers per EC2 instance. The worker is a Node.js process in a Docker container. Docker is not a necessity, but makes deploying easier as you’ll see in the next chapter. The worker uses the <a href="https://github.com/bbc/sqs-consumer">SQS consumer library</a>. When a job finishes, it calls a <code>done()</code>callback which deletes the message from the queue.</li><li>If work is not finished successfully, the <code>done()</code> callback is never called or is called with an error <code>done(err)</code>. This triggers SQS specific behaviour where the message becomes visible again in the queue and other workers can pick it up. This is key, as we are now free to kill a worker without missing any work. This is an SQS function but comes with almost any queueing platform.</li><li>If work is finished successfully, the result is posted to another queue for processing and storage.</li></ol><p>Applying this pattern solves our architecture related problems to the pattern’s inherent load balancing and decoupling attributes. Of course, this pattern also allows for pretty easy scaling. More messages === more workers.</p><p>Moreover, this also allows for some measure of <strong>auto scaling</strong> based on load characteristics like the amount of messages in a queue (and their relative age) or the 1m, 5m and 15m load average of the EC2 instances. The reason for this is that scaling up is easy, but scaling down without annoying users or impacting your service is a lot harder. Solving this issue for deployments also solves it for auto scaling. Two birds with one stone.</p><blockquote>For anything even remotely stateful or interactive (i.e. API / Web servers with session state, data sources etc.) this pattern is pretty much a no go without something like request draining, sticky session based routing or a central session storage.</blockquote><h2 id="terraform-modules-and-config">Terraform modules and config</h2><p>As mentioned earlier, Terraform provides you with two primitives to do zero downtime deployments.</p><ul><li>the <code>create_before_destroy</code> flag in the <code>lifecycle</code> configuration block. Kinda speaks for itself. You can’t kill the existing servers before the new ones are up.</li><li>the <code>local-exec</code> or <code>remote-exec</code> provisioner. This executes a command. When it return, Terraform continues its plan execution.</li></ul><p>As you’ll find out, you need a bunch of other things to pull this off over multiple regions. Let’s look at an<code>aws_instance</code> configuration in a .tf file for Checkly.</p><!--kg-card-begin: markdown--><pre><code class="language-java">// workers/module.tf resource &quot;aws_instance&quot; &quot;browser-check-worker&quot; { ami = &quot;${data.aws_ami.default.id}&quot; // AWS Linux AMI instance_type = &quot;${var.instance_type}&quot; count = &quot;${var.count}&quot; tags { Name = &quot;browser-check-worker-${count.index}&quot; Version = &quot;0.9.0&quot;, Env = &quot;${var.env}&quot; // prod or test } user_data = &quot;${var.user_data}&quot; // User data pulls &amp; starst the app key_name = &quot;checkly&quot; lifecycle { create_before_destroy = true } // Every 5 seconds, check if the launcher.js process is up. provisioner &quot;remote-exec&quot; { inline = [ &quot;until ps -ef | grep [l]auncher.js &gt; /dev/null; do sleep 5; done&quot; ] connection { type = &quot;ssh&quot; user = &quot;ec2-user&quot; private_key = &quot;${file(&quot;~/.ssh/checkly.pem&quot;)}&quot; } } } </code></pre><!--kg-card-end: markdown--><p>Some take-aways from this file:</p><ol><li>We can tweak the AMI type, instance type and total instances per region.</li><li>We explicitly tag each EC2 instance with the version of the code it is running.</li><li>We pull in a <code>user-data.yml</code> file that bootstrap the application. See more details below.</li><li>We provision a SSH key so we can connect to the instance.</li></ol><p>The payoff is in using the <code>remote-exec</code> provisioner (that uses the SSH key). It checks every 5 seconds if the <code>launcher.js</code> process is running. Note we use the <code>grep [l]auncher.js</code> syntax to exclude the grep command itself from the process listing. Not doing this would instantly return this command and defeat the whole purpose.</p><p>Admittedly, this is fairly simplistic, but for our use case it does exactly what is needed. The existence of the launcher process means we have our code running and it is ready to read new messages from the SQS queue.</p><p>To fully grasp this, we need to look at a user-data file.</p><!--kg-card-begin: markdown--><pre><code class="language-yaml">#cloud-config packages: - docker write_files: - path: /root/.profile owner: root:root permissions: '0644' content: | # ~/.profile: executed by Bourne-compatible login shells. if [ &quot;$BASH&quot; ]; then if [ -f ~/.bashrc ]; then . ~/.bashrc fi fi export NODE_ENV=production export AWS_REGION=ap-south-1 export WORK_QUEUE=https://sqs.ap-south-1.amazonaws.com/xxxx/checks export RESULTS_QUEUE=https://sqs.ap-south-1.amazonaws.com/xxxx/results runcmd: - service docker start - [., /root/.profile] - [docker, login, -u, checkly, -p, &quot;pwd&quot;] - [docker, pull, &quot;checkly/browser-checks-launcher:latest&quot;] - . /root/.profile &amp;&amp; docker run -d -e NODE_ENV=$NODE_ENV ... checkly/browser-checks-launcher:latest </code></pre><!--kg-card-end: markdown--><ol><li>We make the <code>docker</code> package a requirement. The AWS AMI we use has Docker preinstalled, but who knows…</li><li>We create a <code>.profile</code> file that contains the necessary environment variables our workers need to operate like the addresses of the two queues it communicates with, what region it is serving and in what environment it is working (production or test).</li><li>At boot, we start Docker and login to our private Docker repo. We pull the latest image of our worker and <code>docker run</code> the image, passing in all the environment variables.</li></ol><p>Remember, none of this marks our new instance as “finished” from a Terraform perspective. The <code>remote-exec</code> command only returns after the docker container is fully running and has started the relevant node process.</p><p>The result looks as follows:</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://checklyhq.com/blog/ec2_browser_instances.ed8f70e2.png" class="kg-image" alt="An in-depth look at 100% Zero Downtime deployments with Terraform"></figure><!--kg-card-end: image--><p>Note that this process is fairly generic. You can do the same thing for any Dockerized app or any Ruby, Python, Java, whatever app.</p><p>The AWS multi region Terraform configuration is very specific to how AWS manages naming, resources, access etc. per region. We also have Terraform configurations for Digital Ocean and they make it <em>a lot</em>simpler to pull this off. We make use of the Terraform strategy <a href="https://medium.com/@ctindel/multi-region-aws-app-deployments-with-terraform-modules-859c9ecb64f4">described in this blog post</a>.</p><p>The main thing to grasp is that for each AWS region, you create a module in your <code>main.tf</code> file, and reference the a template using the <code>source</code> attribute.</p><!--kg-card-begin: markdown--><pre><code class="language-java">// main.tf module &quot;workers-us-east-1&quot; { source = &quot;workers&quot; region = &quot;us-east-1&quot; count = 1 user_data = &quot;${file(&quot;user-data-us-east-1.yml&quot;)}&quot; env = &quot;prod&quot; } module &quot;workers-us-west-1&quot; { source = &quot;workers&quot; region = &quot;us-west-1&quot; count = 3 user_data = &quot;${file(&quot;user-data-us-west-1.yml&quot;)}&quot; env = &quot;prod&quot; } ... </code></pre><!--kg-card-end: markdown--><p>This leverages Terraform’s module hierarchy and allows you to fly in different variables for different regions. More importantly, it enables to deploy to multiple regions with one command.</p><blockquote>But why create new instances anyway? The worker is published as a Docker container, can’t we just pull a new container, cycle the old one and be done with it? Yes, that works. We use it during development all the time. However, for production we want to be sure configuration hasn’t drifted due to manual intervention.</blockquote><h2 id="deployment-workflow">Deployment workflow</h2><p>After setting all of this up, how do we release a new version of our worker? For Checkly, the steps are as follows:</p><p>First, we build a new Docker container. Tag it as latest and push it to our private repo. Nothing special here.</p><p>Secondly, we update the version in our <code>module.tf</code> file.</p><p>We then use the Terraform <code>taint</code> command to force a create/destroy cycle. Why? Because Terraform has no way of knowing that we want to pull a new container. Just bumping the version is not sufficient to trigger a replacement of the EC2 instance.</p><!--kg-card-begin: code--><pre><code>terraform taint -module=runners-us-west-1 aws_instance.browser-check-worker</code></pre><!--kg-card-end: code--><p>Notice that the <code>-module</code> targets an AWS region as per the module declarations in the <code>main.tf</code> file. From here, it is a straightforward <code>terraform plan</code> and/or <code>terraform apply</code> and ✨ behold the zero downtime magic. ✨</p><p>It doesn’t take a genius to see that this can be turned into a script that runs on a CI/CD platform pretty easily. It follows the general pattern of:</p><ul><li>build</li><li>test</li><li>package</li><li>deploy</li><li>monitor</li></ul><p>Where each stage can break and return control to the operator. Your CI/CD platform will probably shoot you an email when that happens.</p><h2 id="monitoring">Monitoring</h2><p>All of the above might fail. Reasons for failure might be as obtuse as AWS changing some API (breaking Terraform), your buggy code or just it being Friday afternoon. In general, failures fall into two camps:</p><ol><li><strong>Deployment failures</strong>. These are easy and tricky at the same time. Firstly, they show up as you deploy. Your Terraform command returns an error. This can leave your multi region deployment in an undetermined state. I would recommend writing your code in such a way that your app can handle this. The alternative, a full roll back, tends to be even harder. Some manual work may be required.</li><li><strong>Code failures</strong>. Your new version might deploy and even boot fine. It just might fail on some logic errors the moment it starts receiving traffic. For this you should either instrument your code with error tracking service like Sentry, Bugsnap or Rollbar. Next to that, I highly recommend having some sort of alert trigger “when nothing happens” for an x amount of time. For Checkly, we run <a href="https://appoptics.com/">appoptics.com</a>(formerly Librato) and it alerts us when “nothing happens” for a workers in a specific region.</li></ol><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://checklyhq.com/blog/worker_trigger.7e9b4dda.png" class="kg-image" alt="An in-depth look at 100% Zero Downtime deployments with Terraform"></figure><!--kg-card-end: image--><p>Note that this only works because our code explicitly calls the AppOptics API on each run, together with some basic details on what region the worker is running in, using the following code.</p><!--kg-card-begin: markdown--><pre><code class="language-js">const axios = require('axios') axios.defaults.baseURL = `https://${config.appOptics.apiToken}@api.appoptics.com/v1` const namespace = 'checkly' const trackRunCount = function () { const payload = { tags: { region: process.env.AWS_REGION || 'local' }, measurements: [ { name: `${namespace}.browser-check-worker.count`, value: 1 } ] } } </code></pre><!--kg-card-end: markdown--><p>This is, again, specific to our situation as users don’t interact with the workers directly. In a typical client/web server scenario the amount of 500 errors, or the lack of 200 response codes could function as a similar trigger. In the end, <strong>you need to establish your app is processing user requests successfully, regardless of whether your deployment was successful</strong>.</p><p>Terraform also <a href="https://www.terraform.io/docs/providers/type/monitor-index.html">provides a ton of monitoring providers</a> that you can hook into your deployment routine. If your particular monitoring solution is there, use it.</p><h2 id="conclusion">Conclusion</h2><p>Doing zero downtime deployments with Terraform without causing service disruption is a bit more involved than just using the right Terraform commands and configuration. Takeaways are:</p><ul><li>Your architecture determines how easy / hard it is to do zero downtime deployments.</li><li>Working infrastructure does not equal a working service.</li><li>Everything can break, use monitoring at the infrastructure and service level.</li><li>Humans will be needed when things break.</li></ul><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><p></p><p><em>banner image: Sailing on a Blue Ocean” by Shotei Takahashi (1871-1945) - <a href="http://www.jaodb.com/db/ItemDetail.asp?item=38681">Japanese Open Art Database</a></em></p>
]]>
            </content:encoded>
        </item>
        <item>
            <title>
                <![CDATA[
An Opinionated List of Skills You Need for a DevOps Job in 2018
]]>
            </title>
            <description>
                <![CDATA[
A biased, but hopefully helpful list of technical and organisational skills that I would look for when hiring someone for a DevOps position.
]]>
            </description>
            <link>
https://blog.checklyhq.com/an-opinionated-list-of-skills-you-need-for-a-devops-job-in-2018/
            </link>
            <guid isPermaLink="false">5c8910aa167d1600cc2a19a5</guid>
            <category>
                <![CDATA[ devops ]]>
            </category>
            <dc:creator>
                <![CDATA[ Tim Nolet ]]>
            </dc:creator>
            <pubDate>Thu, 04 Oct 2018 13:16:00 GMT</pubDate>
            <media:content url="https://blog.checklyhq.com/content/images/2019/03/devops_skills.56369edc.jpg" medium="image"/>
            <content:encoded>
                <![CDATA[
<img src="https://blog.checklyhq.com/content/images/2019/03/devops_skills.56369edc.jpg" alt="An Opinionated List of Skills You Need for a DevOps Job in 2018"><p>The world of DevOps is a pretty confusing place for folks just starting out. Even figuring out what “DevOps” means can be hard. Is it <strong>CI/CD with Kubernetes and Serverless</strong> to drive Agile™ product iterations? Or is it SSH-ing into a box and <strong>restarting Apache</strong>? You guessed it. All of the above and most things in between.</p><p>After ~20 years in Ops and later Dev I thought I’d write up a biased, but hopefully helpful list of <strong>technical and organisational skills</strong> that I would look for when hiring someone for a DevOps position.</p><p><em>2018-10-11: Keen Reddit user mentioned I forgot Git. He was right and I added it.</em></p><h2 id="1-deploying-">1. Deploying.</h2><p>DevOps is very much related to “releasing stuff” and making that work without a hitch. If there is <em>anything</em>you should get paranoid about it is managing, prepping, rehearsing, checking (and later automating) releases and deployments. Regardless of language, platform, framework, sector, industry or any other technical / organisational details this is the thing that REALLY matters.</p><blockquote>💡 Two life tips: Don’t buy pans from Ikea and never deploy on Fridays.</blockquote><h2 id="2-monitoring">2. Monitoring</h2><p>Intrinsically connected to deploying is making sure that deployments work as expected and within parameters. This is about as vague as it gets. Just make sure you are somewhat comfortable with the various types of monitoring out there: uptime monitoring, process monitoring, real-user monitoring, synthetic monitoring etc. The bigger, more complex your stack, the more of these you will need. Again this the bread &amp; butter. Screw this up and you are dead and blind.</p><blockquote>💡 Nagios, Graphite and other “old school” tools are still very useful to grasp the essentials.</blockquote><h2 id="3-http">3. HTTP</h2><p>Learn how HTTP works. Obsess over tools like curl and your browsers debugger network panel. 99% of your tools and API’s speak it. All your SaaS providers speak it. Being able to interpret HTTP traffic and write simple scripts that “do HTTP” is a gift that will keep on giving. Hungry for more? Dive into TCP also.</p><blockquote>💡 Try a telnet session and <a href="http://coryforsyth.com/2014/04/06/hand-crafted-http-with-telnet-exploring-the-protocol/">type the HTTP protocol by hand.</a></blockquote><h2 id="4-ssh">4. SSH</h2><p>Next to HTTP, SSH is basically essential. It lets you quickly navigate and troubleshoot almost any current stack. Except the serverless ones I guess. Creating and using keys and swift usage of any SSH client (whether on Linux or Windows) must feel like second nature. Strangely, FTP seems to be going extinct.</p><blockquote>💡 Tunnelling over SSH will save you one day. <a href="https://www.ssh.com/ssh/tunneling/example">Learn it</a></blockquote><h2 id="5-cpu-process-and-storage">5. CPU, process and storage</h2><p>You need to have a basic understanding of how a computer works, again regardless of the platform. Why? Because you will encounter issues with stuck programs, corrupt files, performance bottlenecks, i.e. complaining end users or coworkers. In 99% of cases, this is due to resource contention somewhere.</p><p>Regardless of the cause (bad programming, failing disks, slow CPU) you will need to get a knack for recognising where to look. Over time, you will recognise patterns “this reminds of that crashing disk issue we once had”, or “seems like Java just hasn’t got enough memory and is GC-ing all the time”.</p><blockquote>💡 Try to REALLY understand the output of <code>top</code> on *NIX or its Windows equivalent.</blockquote><h2 id="6-triaging">6. Triaging</h2><p>Probably the easiest way to spot a junior engineer is observing how they go about finding the root cause of some arcane bug or mysterious outage. Don’t get me wrong, this is a hard skill to grow. The systematic process of identifying, analyzing, developing and implementing a remedy for a problem is something you just have to do a lot to master it. It is the opposite of “have you tried turning it off and on again?”. This skill also transfers well to other business domains and even your daily life.</p><blockquote>💡 Read error messages. You’d be amazed how many people skip this essential step.</blockquote><h2 id="7-databases">7. Databases</h2><p>You don’t have to be a full blown DBA. You do need to recognise that databases are in general still a “hard” problem to solve. In comparison, (stateless) API’s, web servers, application servers etc. are all fairly low risk, low maintenance and almost complete commodity. Databases, distributed or not, are still hard and tend to hold a ton of value for your company. Learn some SQL, read the Mongo docs or just go with Postgres, the best database in the world™.</p><blockquote>💡 ORM’s are not an excuse to not grasp how databases function.</blockquote><h2 id="8-ci-cd">8. CI/CD</h2><p>Continuous Integration and Continuous Deployment only at place eight? That should be number one, right? Actually, no. Without understanding how databases and migrations work I dare you to create a useful deployment pipeline. Without understanding how HTTP works and how sessions are (not) handled, I dare you to do continuous deployment without interrupting users and generally creating a very bad time for your customers and coworkers.</p><blockquote>💡 Master doing things manually. Understand them deeply. Only then automate them.</blockquote><h2 id="9-git">9. Git</h2><p>I started with CVS and SVN. They are pretty fine source code versioning tools. But Git is way more than that in a DevOps context. Git (with Github or Gitlab or any hosted platform) is now your bookkeeper, collaboration platform, todo list and many more things. Versioning is just one part of it. Learn it.</p><blockquote>💡 Reset, rebase and merge fixes can be tricky. There is no shame in using a UI tool.</blockquote><h2 id="10-risk-assessment">10. Risk assessment</h2><p>Isn’t this part of deploying? Kind of, but with added security and business insights. As you and your organisation mature you will have to judge whether the path you are taking is safe, secure and even legal in the broadest sense. Storing those user files in S3? Porting production backups to test environments?</p><p>Many times your product and business coworkers will not see (or care) about the risks involved. Technical people can leverage their general paranoia here for good. Be critical. Block unsafe, risky or careless proposals, or at least raise your voice.</p><blockquote>💡 Security testing or penetration testing help. Do them quarterly.</blockquote><h2 id="11-load-performance-testing">11. Load &amp; performance testing</h2><p>You will need to be able to at least make a guesstimation on performance for new products or features. Even in the age of auto scaling and quick cloud provisioning. Remember that databases, some external services or expensive / specific hardware don’t not scale that well. Start with simple tools like Apache Bench and slowly ramp up to platforms like Jmeter or Gatling. Try to use data and usage patterns that are somewhat representative of real users. This is hard.</p><blockquote>💡 Don’t expect load patterns found in test to translate 1:1 to prod. Stay vigilant.</blockquote><h2 id="12-language-runtimes-and-their-configuration">12. Language runtimes and their configuration</h2><p>One language shops exist, but don’t bet on it. Get some inkling on how a basic app is build, started and configured for multiple platforms. Building and running a Node.js app is pretty different from a Java / JVM app, which can be split into Scala an Kotlin and Clojure variations. They use different package managers, require different types of monitoring and have different resource usage patterns.</p><blockquote>💡 Starting with a JVM language helps, even if your shop doesn’t use Java.</blockquote><h2 id="13-infrastructure-as-code">13. Infrastructure as code</h2><p>You can do CI/CD easily without any automated infrastructure provisioning. And infrastructure as code is not a super valuable “business booster”. Except when things get bigger and scale happens. This can also be “internal scale” when you have to duplicate environments for development and testing purposes. Get handy with Terraform, Ansible, Puppet or AWS Cloudformation. Spinning up a new environment with the touch of a button is pretty damn cool also.</p><blockquote>💡 Don’t try to get 100% full reproducibility. It is an endless time sink.</blockquote><h2 id="14-developer-experience">14. Developer Experience</h2><p>You are expensive and so are your developer pals. Keeping them happy is actually pretty important on many levels. The term “DX” is pretty new but makes sense. As the DevOps mindset enters an organisation tools, platforms and infrastructure can get overwhelming. A smooth, transparent workflow where teams can easily access resources, ship new projects and get feedback on their new services is a holy grail for many companies. There is no easy solution for this. Listen and take baby steps.</p><blockquote>💡 Sometimes a cup of coffee or having lunch together is all the DX that is needed.</blockquote><h2 id="15-containers">15. Containers</h2><p>(Docker) containers are here to stay, so you probably need to get comfortable with the eco system. None of this is terribly hard, especially not if you have some Linux chops. Most important is to recognize when to use them and when they are just an unnecessary burden. Do not “containerize all the things”.</p><blockquote>💡 Docker portability between Mac, Windows and *NIX is not 100%. Expect some issues.</blockquote><h2 id="16-container-orchestration">16. Container orchestration</h2><p>In a mature technical organisation at some form of scale, you will be introduced to container orchestration issues at some stage. It is where the industry is going. By all means, use Kubernetes or any of its competitors but remain critical.</p><p>Compared to using just Docker to wrap some apps in container, using any container orchestration tool is a significantly bigger investment in time and money. Remember, this tech is quite young, so only use it when you are feeling the pain of <em>not</em> using it.</p><blockquote>💡 Get a hosted solution if you can.</blockquote><h2 id="further-reading">Further reading</h2><p>This a list of books useful books, even if some of them might seem dated. The books are listed alphabetically by author. Not all are strict “DevOps” book, but all have valuable content related to the skill areas mentioned above.</p><p>DeMarco, Tom. e.a. <a href="https://www.amazon.com/Peopleware-Productive-Projects-Tom-DeMarco/dp/0932633439">Peopleware</a> - <em>Mostly on soft skills and project management. Still highly relevant in tech circles.</em></p><p>Grigorik, Ilya. <a href="https://www.amazon.com/High-Performance-Browser-Networking-performance-ebook/dp/B00FM0OC4S">High Performance Browser Networking</a> - <em>Everything you need to grasp HTTP from a web perspective.</em></p><p>Humble, Jez. e.a. <a href="https://www.amazon.com/Continuous-Delivery-Deployment-Automation-Addison-Wesley/dp/0321601912">Continuous Delivery</a> - <em>Essential to grasp the current CI/CD, Agile and DevOps scene.</em></p><p>Martin, Robert C. <a href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/">Clean Code</a> - <em>Java oriented, but whatever language you work with you will recognize things from this book.</em></p><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><p><em>banner image: “Casting an Invocation on the Waves at Kakuda in Sado Province” by Utagawa Kuniyoshi (1797-1861) - <a href="http://honolulumuseum.org/art/exhibitions/11514-pathways_evolution_japanese_buddhist_prints/">Honolulu Museum of Art</a></em></p>
]]>
            </content:encoded>
        </item>
        <item>
            <title>
                <![CDATA[
How we got a 100% Lighthouse performance score for our Vue.js app
]]>
            </title>
            <description>
                <![CDATA[
It took about half a day to go from an 34 to a 100 Lighthouse score on our Vue.js app. Here's how we did it.
]]>
            </description>
            <link>
https://blog.checklyhq.com/how-we-got-a-100-lighthouse-performance-score-for-our-vue-js-app/
            </link>
            <guid isPermaLink="false">5c890ea2167d1600cc2a1963</guid>
            <category>
                <![CDATA[ javascript ]]>
            </category>
            <category>
                <![CDATA[ vue ]]>
            </category>
            <category>
                <![CDATA[ chrome ]]>
            </category>
            <dc:creator>
                <![CDATA[ Tim Nolet ]]>
            </dc:creator>
            <pubDate>Thu, 23 Aug 2018 13:15:00 GMT</pubDate>
            <media:content url="https://blog.checklyhq.com/content/images/2019/03/tunnel1.d2385cae.jpg" medium="image"/>
            <content:encoded>
                <![CDATA[
<img src="https://blog.checklyhq.com/content/images/2019/03/tunnel1.d2385cae.jpg" alt="How we got a 100% Lighthouse performance score for our Vue.js app"><p>Since launch, we didn’t pay too much attention to the front end performance of the main Checkly web app. Shame on us. What better reason to dive into this than the publishing of the excellent <a href="https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4">The Cost of Javascript in 2018</a> by Google’s Addy Osmani?</p><p>TL;DR: it took about half a day to go from <strong>an abysmal 34 to a 100 Lighthouse score</strong> on our Vue.js app.</p><h2 id="very-short-primer-on-web-app-performance">Very short primer on web app performance</h2><p>The article by Osmani goes into why web/mobile performance is important, what Javascript has to do with it and what concerns there are regarding mobile, device type, render cycles, loading etc. Read it if you are not familiar with these topics. The gist is:</p><ol><li>Javascript is the most expensive part of your site performance wise. Not images, not CSS.</li><li>Faster sites increase revenue.</li><li>Optimizing javascript for performance is a multi-step, audience and device specific process.</li></ol><p>If you’re hungry for more, hop over to <a href="https://hpbn.co/">high performance browser networking</a> by Ilya Grigorik (also at Google) for some more in depth knowledge around this topic.</p><h2 id="running-lighthouse">Running Lighthouse</h2><p>To get a handle on the current performance of the Checkly app, I ran <a href="https://developers.google.com/web/tools/lighthouse/">Lighthouse</a> on the login screen. Lighthouse is a performance auditing tool embedded in every Chrome browser.</p><p>Admittedly, the login page is not where most users spend most of their time, but it is definitely the page everyone will always have to deal with at least once.</p><p>Lighthouse ran with the following settings to optimize for the intended audience:</p><ul><li><strong>Device: desktop.</strong> Mobile or tablet usage is not really a factor (yet?) for Checkly’s current audience.</li><li><strong>Audits: performance.</strong> Other options are SEO, Accessibility etc. We are only interested in performance here.</li><li><strong>Throttling: no throttling.</strong> Checkly is a B2B, DevOps app. 99% of users will be using it in an office. 3G and 4G performance is not really that important.</li></ul><p>Note that the Device and Throttling settings <em>do</em> matter for the site and blog post you are reading right now. At least 25% of checklyhq.com visitors are on mobile.</p><p>We ran the test and the results speak for themselves. A score of 34. Lots of red letters and warning signs. Pretty terrible. 😞</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://blog.checklyhq.com/content/images/2019/03/image-2.png" class="kg-image" alt="How we got a 100% Lighthouse performance score for our Vue.js app"></figure><!--kg-card-end: image--><p>Some “highlights”:</p><ul><li>The first meaningful paint takes over 6 seconds.</li><li>The CPU is busy for a full second longer.</li></ul><h2 id="first-stop-bundle-size">First stop: bundle size</h2><p>I had a nagging feeling that the amount of Javascript we were shipping was “sub optimal”. Webpack has the great <a href="https://www.npmjs.com/package/webpack-bundle-analyzer">Bundle Analyze</a> plugin that tells you exactly what you are packing (and shipping). A quick NPM install and a couple of lines in your Webpack config and you’re running:</p><!--kg-card-begin: markdown--><pre><code class="language-bash">npm i -D webpack-bundle-analyzer </code></pre><!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class="language-js">const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin ... plugins: [ new BundleAnalyzerPlugin() ] ... </code></pre><!--kg-card-end: markdown--><p>This will start up a browser after each build and show you something similar to this:</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://blog.checklyhq.com/content/images/2019/03/image-3.png" class="kg-image" alt="How we got a 100% Lighthouse performance score for our Vue.js app"></figure><!--kg-card-end: image--><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><p>Yes. That is a total of 2.01MB of (uncompressed) javascript Checkly was shipping. A far cry from the 170KB compressed / 0.7MB uncompressed that is adviced as a ball park figure in the Cost of Javascript article.</p><p>Our Webpack setup is based on the settings introduced by Vue-CLI and splits code into <strong>vendor</strong>, <strong>app</strong> and <strong>manifest</strong> files as you can see in the screenshot above. This is a common practice and really helps with caching the vendor dependencies for a long time, while still enabling you to update your app on a regular basis.</p><p>We attacked the <strong>vendor.js</strong> file first.</p><h3 id="gutting-moment-js-1-75mb-1-58mb">Gutting moment.js: 1.75MB -&gt; 1.58MB</h3><p>Moment.js is a great date and time handling library. It just ships with a full range of locale files. We use none in our app. Sadly there is no way to optionally install them and it turns out <a href="https://github.com/moment/moment/issues/2416">we are not the only ones slightly annoyed by this</a>. We got rid of the locales using the built in Webpack Ignore plugin:</p><!--kg-card-begin: markdown--><pre><code class="language-js"> plugins: [ new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/) ] </code></pre><!--kg-card-end: markdown--><h3 id="gutting-codemirror-1-58mb-1-05mb-">Gutting Codemirror: 1.58MB -&gt; 1.05MB (!)</h3><p>Codemirror is used on the browser check edit screen in the Checkly app. As with Moment.js, it ships with a whole bunch of code styles and themes we we’re not using. Lucky us, there was already a thin Vue.js wrapper for a slimmed down Codemirror install called <a href="https://github.com/cnu4/vue-codemirror-lite">VueCodeMirrorLite</a>. After some minor code tweaks and a separate install of the Monokai theme and Javascript code style we saved almost 0.5MB!</p><h3 id="removing-full-lodash-1-05mb-1019-82kb">Removing full lodash: 1.05Mb -&gt; 1019.82KB</h3><p>A quick code scan showed we only used four methods of Lodash (<code>clonedeep</code> is gold). We ditched the full install and just installed the methods we actually used. Kudos to the Lodash people for supporting this.</p><h3 id="selective-import-of-bootstrap-vue-1019-82kb-934-75kb">Selective import of bootstrap-vue: 1019.82KB -&gt; 934.75KB</h3><p>Parts of the UI are using a Vue.js-ified version of Bootstrap called <a href="https://bootstrap-vue.js.org/">Bootstrap Vue</a>. By just importing the modules from the library we are using (modals, tooltips, navs etc.) we got the vendor.js bundle under 1MB 🎉</p><h2 id="second-stop-code-splitting">Second stop: Code Splitting</h2><p>To attack the <strong>app.js</strong> file, we looked at code splitting. The idea of code splitting is that you serve the right amount of javascript at the right moment using XHR calls. This means there is no big initial, up front cost to load the full application. This should result in a quicker time to first paint and subsequent interaction.</p><p><a href="https://vuejsdevelopers.com/2017/07/03/vue-js-code-splitting-webpack/">This great article</a> on code splitting in Vue.js describes the nitty gritty. The gist is:</p><ol><li>You want to use components, “Single File” or not. (at Checkly we use separate <code>.pug</code> and <code>.scss</code>files)</li><li>You want to use Webpack. Read the mentioned article on how to set this up. If you use Vue-CLI for starting a Vue app, you are already good.</li><li>You want to split by route. There are other options, but this is by far the most straightforward one and nicely mimics traditional (non SPA) sites by requesting resources on page navigation.</li></ol><p>I was happily surprised that literally the only changes need in our app were a list of import statements in our <code>router.js</code> file. This might not work for everyone, but in the Checkly app, each route neatly maps to one master/container component</p><p>This:</p><!--kg-card-begin: markdown--><pre><code class="language-js">import Login from './components/authentication/login' import Signup from './components/authentication/signup' ... </code></pre><!--kg-card-end: markdown--><p>Becomes this:</p><!--kg-card-begin: markdown--><pre><code class="language-js">const Login = () =&gt; import('./components/authentication/login') const Signup = () =&gt; import('./components/authentication/signup') ... </code></pre><!--kg-card-end: markdown--><p>You are now effectively changing the standard <code>import from</code> statements into Webpack specific <code>import()</code> statements enabling the splitting and asynchronous loading of your components. Your route assignment code doesn’t even change:</p><!--kg-card-begin: markdown--><pre><code class="language-js"> routes: [ { path: '/login', name: 'login', component: Login }, { path: '/signup', name: 'signup', component: Signup } ... </code></pre><!--kg-card-end: markdown--><p>After rebuilding and reloading the app, it will seem as if nothing has changed. However, opening the Network tab in the Dev Tools shows the nicely numbered javascript chunks flying over the network when navigating routes.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://checklyhq.com/blog/cost3.34df5a9a.png" class="kg-image" alt="How we got a 100% Lighthouse performance score for our Vue.js app"></figure><!--kg-card-end: image--><h2 id="running-lighthouse-again">Running Lighthouse again</h2><p>We were pretty happy with the bundle size reduction and how easy it was to implement code splitting. We were not prepared for the huge impact it had. Running Lighthouse again — same settings as mentioned above — painted a totally different picture: A score of 100 and green text everywhere! Wow!</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://checklyhq.com/blog/cost4.10f02d34.png" class="kg-image" alt="How we got a 100% Lighthouse performance score for our Vue.js app"></figure><!--kg-card-end: image--><p>As mentioned, the login page is not the most exciting thing going on in the app. We ran the test on the home dashboard and check results pages, which both contain a fair amount of XHR calls, data parsing and graph drawing.</p><p><strong>home dashboard</strong></p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://checklyhq.com/blog/cost5.5a64c2b3.png" class="kg-image" alt="How we got a 100% Lighthouse performance score for our Vue.js app"></figure><!--kg-card-end: image--><p><strong>check results</strong></p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://checklyhq.com/blog/cost6.095f4fba.png" class="kg-image" alt="How we got a 100% Lighthouse performance score for our Vue.js app"></figure><!--kg-card-end: image--><p>For both screens you can see that the “First CPU Idle” and “Time To Interactive” are roughly double that of the simple log in screen, but still pretty OK according to Lighthouse.</p><h2 id="conclusion">Conclusion</h2><p>The optimizations above took about 4 to 6 hours to implement, test and roll out. Most of that time was spent on minor code tweaks to optimize the modules and libraries used. Time well spent!</p><p>Just remember to work in iterations where you</p><ol><li>Target an area.</li><li>Optimize.</li><li>Measure the results.</li><li>GOTO 1.</li></ol><!--kg-card-begin: hr--><hr><!--kg-card-end: hr--><p><em>banner image: “High Speed Tunnel” by Sekino Junichiro (late 20th century) - <a href="https://ukiyo-e.org/image/artelino/15177g1">Ukiyo.org</a></em></p>
]]>
            </content:encoded>
        </item>
        <item>
            <title>
                <![CDATA[
Creating a Chrome extension in 2018: The good, the bad and the meh
]]>
            </title>
            <description>
                <![CDATA[
This post talks you through the development lifecycle when creating a Chrome extension and lists some of the architectural gotcha’s.
]]>
            </description>
            <link>
https://blog.checklyhq.com/creating-a-chrome-extension-in-2018-the-good-the-bad-and-the-meh/
            </link>
            <guid isPermaLink="false">5c890abc167d1600cc2a1919</guid>
            <category>
                <![CDATA[ building a saas ]]>
            </category>
            <category>
                <![CDATA[ javascript ]]>
            </category>
            <category>
                <![CDATA[ vue ]]>
            </category>
            <category>
                <![CDATA[ chrome ]]>
            </category>
            <dc:creator>
                <![CDATA[ Tim Nolet ]]>
            </dc:creator>
            <pubDate>Thu, 16 Aug 2018 12:50:00 GMT</pubDate>
            <media:content url="https://blog.checklyhq.com/content/images/2019/03/workers1.91bd6791.jpg" medium="image"/>
            <content:encoded>
                <![CDATA[
<img src="https://blog.checklyhq.com/content/images/2019/03/workers1.91bd6791.jpg" alt="Creating a Chrome extension in 2018: The good, the bad and the meh"><p>Last week, we shipped an initial version of <a href="https://chrome.google.com/webstore/detail/puppeteer-recorder/djeegiggegleadkkbgopoonhjim
]]>
                <![CDATA[
gehda">Puppeteer Recorder</a>, a Google Chrome extension that records your browser interactions and generates a Puppeteer script.</p><p>It turns out Chrome extension development is <em>almost</em> like real web development, but with a weird dash of quasi embedded development mixed in.</p><p>This post talks you through the development lifecycle when creating an extension and lists some of the architectural gotcha’s. Source code for the extension in question is on <a href="https://github.com/checkly/puppeteer-recorder">github</a>.</p><h2 id="architecture">Architecture</h2><p>Google’s documentation does a fairly ok job of talking you through all the moving parts of an extension in their <a href="https://developer.chrome.com/extensions/getstarted">getting started guide</a>. However, the docs mix explaining secondary concerns / aspects like security, packaging, setting icons etc. with the five core architectural components. You would do well to set up your project’s code structure to reflect these five core components, i.e.</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://checklyhq.com/blog/chrome_extension_project_layout.6c59ecf7.png" class="kg-image" alt="Creating a Chrome extension in 2018: The good, the bad and the meh"></figure><!--kg-card-end: image--><p>So they reflect the components in the extension:</p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://developer.chrome.com/static/images/overview/messagingarc.png" class="kg-image" alt="Creating a Chrome extension in 2018: The good, the bad and the meh"></figure><!--kg-card-end: image--><ul><li><strong>manifest.json</strong></li></ul><p>This file bootstraps your extension and provides meta data like versioning. Without this, you have no extension.</p><ul><li><strong>background scripts</strong><br></li></ul><p>The heart and soul of your extension. This is where you create a listener to actually trigger the popup when users click you icon. All “hard” business logic and native browser interaction should go in here as much as possible.</p><ul><li><strong>content scripts</strong><br></li></ul><p>Content scripts can be injected into the tabs in the browser and access the DOM in the context of a browser session. This is where you can add new DOM elements, add extra listeners etc. Note: content scripts are optional</p><ul><li><strong>popup UI</strong></li></ul><p>The little app you see when clicking/activating an extension. Can be build with any framework like React or Vue or just vanilla JS. We used Vue.</p><ul><li><strong>options page UI</strong></li></ul><p>A dedicated page for customising settings of your extension. This page should persist any settings to the store, to be fetched again by other parts of your plugin.</p><h2 id="the-chrome-global">The <code>chrome</code> global</h2><p>Meet your new best friend 👫, the <code>chrome</code> global. You will be spending a lot of time together! Its primary functions are:</p><ul><li><strong>Registering listeners &amp; handlers</strong> on browser navigation and interface clicks. In the example below you can see an abbreviated version of the <code>start()</code> function that runs when you click ‘Record’ in the popup UI.</li></ul><!--kg-card-begin: markdown--><pre><code class="language-js">function start () { // Inject the content script chrome.tabs.executeScript({file: 'content-script.js'}) // add various handlers to events chrome.runtime.onMessage.addListener(MessageHandler) chrome.webNavigation.onCompleted.addListener(NavigationHandler) chrome.webNavigation.onBeforeNavigate.addListener(WaitHandler) // update the icon chrome.browserAction.setIcon({ path: './images/icon-green.png' }) chrome.browserAction.setBadgeText({ text: badgeState }) chrome.browserAction.setBadgeBackgroundColor({ color: '#FF0000' }) } </code></pre><!--kg-card-end: markdown--><ul><li><strong>Accessing storage</strong></li></ul><p>Anything you need to persist over navigations and opening/closing the popup UI should go into either the <code>session</code> or <code>sync</code> store. The <code>sync</code> store should be synced over Chrome browsers hooked up with Chrome Sync. For more, see <a href="https://checklyhq.com/blog/2018/08/creating-a-chrome-extension-in-2018-the-good-the-bad-and-the-meh/#state">State</a> below.</p><p>“Globals are bad ’m kay”. For instance, testing anything that uses them can be a hassle. When globals are used over multiple, normally loosely coupled, objects things get hairy, quickly.</p><p>Having said that, the Chrome team did a good job keeping the <code>chrome</code> global’s interface fairly minimal. Keeping as much of the calls out of your popup UI, where you will probably use a “modern” web framework will keep things sane.</p><h2 id="state">State</h2><p>State is persisted using the native <code>chrome.storage</code> API. No other way around it. This will get/set basically any Javascript object you give it, much like the <code>localStorage</code> API.</p><p>Wrapping it in some non-global function helps keeping things sane. Be sure to check values returning from the store, e.g:</p><!--kg-card-begin: markdown--><pre><code class="language-js">function loadState (cb) { this.$chrome.storage.local.get(['controls', 'code'], ({ controls, code }) =&gt; { console.debug('loaded controls', controls) if (controls) { this.isRecording = controls.isRecording this.isPaused = controls.isPaused } if (code) { this.code = code } cb() }) } function storeState () { this.$chrome.storage.local.set({ code: this.code, controls: { isRecording: this.isRecording, isPaused: this.isPaused } }) } </code></pre><!--kg-card-end: markdown--><p>State is handled slightly different by each architectural component:</p><h3 id="the-popup-s-state-does-not-persist">The popup’s state does not persist</h3><p>When opening &amp; closing the extension by clicking on its icon in the toolbar, the popup looses all state. You need to write everything to the session store and reload it on opening.</p><h3 id="the-background-script-s-state-does-persist">The background script’s state does persist</h3><p>The background script acts a bit like a worker thread, as it is not reloaded unless an explicit reload method is called. This means it should (probably) function as you main source of truth.</p><h3 id="the-content-script-s-state-depends-on-many-things">The content script’s state depends on many things</h3><p>The content script depends completely on page reloads and how/if/when it is injected. In the specific case of Puppeteer Recorder, the content script attaches message handlers to elements in the current page. These handlers send messages of the events we want to record to the background worker.</p><h3 id="storage-has-pretty-tight-limits">Storage has pretty tight limits</h3><p>Yes, 5,242,880 bytes / 5Mb for local and 102,400 / 0.1Mb for sync. There are also restrictions on individual items in the storage. See <a href="https://developer.chrome.com/apps/storage#property-local">the docs</a></p><p>State in browser environments is always tricky, not really an extension issue. Points for the effort 🤙</p><h2 id="messaging">Messaging</h2><p>Communication between components is done by sending messages and adding listeners on, you guessed it, the <code>chrome</code> global.</p><!--kg-card-begin: markdown--><pre><code class="language-js"> chrome.runtime.onMessage.removeListener(handleMsg) chrome.runtime.sendMessage(msg) function handleMsg (msg) { console.log(msg) } </code></pre><!--kg-card-end: markdown--><h2 id="coding">Coding</h2><p>Except for the <code>chrome</code> global and its messaging and state function, there are basically no restrictions to the actual code you write. Any Node.js or front end developer should be pretty comfortable.</p><p>We used ES6/7 with Vue.js for the popup and used most of the common parts of the Vue.js eco (and larger) system like Webpack, Vue test utils and single file components. See <a href="https://checklyhq.com/blog/2018/08/creating-a-chrome-extension-in-2018-the-good-the-bad-and-the-meh/#building">Building</a> for more on this topic.</p><p><strong>Reloading an extension has some quirks</strong> though, as your content script is bound to a dynamically assigned port which goes away after a full reload. This is expected, but the console.log is bombarded with errors. I found no workaround other than adding a <code>try/catch</code> block around the connection and discarding the message.</p><!--kg-card-begin: markdown--><pre><code class="language-js">function sendMessage (msg) { console.debug('sending message', msg) try { chrome.runtime.sendMessage(msg) } catch (err) { console.debug('caught err', err) } } </code></pre><!--kg-card-end: markdown--><h2 id="debugging">Debugging</h2><p>Chrome’s Developer tools are great for debugging your code and this is no different when building an extension. However, you might need as much as four separate Dev Tools windows open to get the full picture: content script, background, popup UI and options UI all run in separate contexts.</p><ul><li><strong>content scripts</strong> use the current browser windows’ Developer Tools.</li><li><strong>background</strong> uses a custom Developer tools, accessible from your extensions page.</li></ul><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://blog.checklyhq.com/content/images/2019/03/image-1.png" class="kg-image" alt="Creating a Chrome extension in 2018: The good, the bad and the meh"></figure><!--kg-card-end: image--><ul><li><strong>popup and options</strong> are opened by right-clicking in the UI of the popup / options window and clicking <strong>Inspect</strong></li></ul><p>Prepare to do some nice window Tetrising! Of course, technically this makes sense, but the workflow suffers tremendously, especially when you are used to React, Vue or vanilla JS app development and you have a neat timeline of all your debug statements etc. in one console.</p><h2 id="building">Building</h2><p>To be fair, you actually do not <em>need</em> to build anything. You can just write plain JS, package it up in a .zip and you’re done. However, when you are used to tech like Vue.js and ES6/ES7 syntax, you will enter the land of Babel and Webpack:</p><ul><li>Transpiling ESx</li><li>Vue.js single file components</li><li>SASS/SCSS compilation</li></ul><p>Getting the build right was a bit tricky as Webpack examples and corresponding versions seem to be deprecated faster than the speed of light.</p><!--kg-card-begin: embed--><figure class="kg-card kg-embed-card"><blockquote class="twitter-tweet"><p lang="en" dir="ltr">I use Webpack everyday. Just like Git. Both are complete black boxes to me. Their error messages are infuriatingly obtuse. I&#39;m in IT 20 years and actually still don&#39;t *really* understand either of them. I love what they do though, so screw it YOLO 🍸🥳</p>&mdash; Tim Nolet 👨🏻‍🚀 (@tim_nolet) <a href="https://twitter.com/tim_nolet/status/1030139648490856451?ref_src=twsrc%5Etfw">August 16, 2018</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></figure><!--kg-card-end: embed--><p>So, long story short, have peek at the <a href="https://github.com/checkly/puppeteer-recorder/blob/master/webpack.config.babel.js">webpack config</a> and corresponding <a href="https://github.com/checkly/puppeteer-recorder/blob/master/webpack.config.babel.js">package.json</a> on Github and you can see what works for Puppeteer Recorder.</p><h2 id="testing">Testing</h2><p>We use <a href="https://jestjs.io/">Jest</a> for testing. We don’t go for 100% test coverage and tests are being added as we speak. They fall into three categories:</p><ol><li>Unit tests at the module or function level.</li><li>UI tests rendering Vue.js components and using Jest <a href="https://jestjs.io/docs/en/snapshot-testing#snapshot-testing-with-jest">snapshots</a> to validate correctness.</li><li>End 2 end tests that build and install the extension.</li></ol><p>For 1 and 2, there is no specific magic except that you have to…</p><h3 id="mock-out-calls-to-the-chrome-global">Mock out calls to the <code>chrome</code> global</h3><p>You need to mock <code>chrome</code>. You can go crazy here, but we managed (for now) to get by with a fairly simple mock. The (edited) example below shows a Vue component being mounted, injected with a mock and asserted. The actual test lives at <a href="https://github.com/checkly/puppeteer-recorder/blob/master/src/popup/components/__tests__/App.spec.js">App.spec.js</a> on Github.</p><!--kg-card-begin: markdown--><pre><code class="language-js">import { mount } from '@vue/test-utils' import App from '../App' const chrome = { storage: { local: { get: jest.fn() } }, extension: { connect: jest.fn() } } const mocks = { $chrome: chrome } describe('App.vue', () =&gt; { test('it has the correct pristine / empty state', () =&gt; { const wrapper = mount(App, { mocks }) expect(wrapper.element).toMatchSnapshot() }) }) </code></pre><!--kg-card-end: markdown--><h3 id="check-build-install-with-puppeteer">Check build &amp; install with Puppeteer</h3><p>In the end you need to deliver a zip file with code to Google to publish on the web store. You probably want to know if the distributable “binary” actually installs. You can test this with Puppeteer. The below example shows how we build the code and install it as an extension in a Chrome instance.</p><p>When using Jest, be sure to run these test cases sequentially by using the <code>--runInBand</code> flag.</p><!--kg-card-begin: markdown--><pre><code class="language-js">import puppeteer from 'puppeteer' import path from 'path' import { scripts } from '../../package.json' const util = require('util') const exec = util.promisify(require('child_process').exec) const extensionPath = path.join(__dirname, '../../dist') describe('build &amp; install', () =&gt; { // Calls the standard 'npm dist' script used to build the distributable test('it builds the extension', async () =&gt; { const { stderr } = await exec(scripts.dist) expect(stderr).toBeFalsy() }, 15000) // boots a Chrome instance using Puppeteer and adds the extension we build in the earlier test test('it installs the extension', async () =&gt; { const options = { headless: false, ignoreHTTPSErrors: true, args: [ `--disable-extensions-except=${extensionPath}`, `--load-extension=${extensionPath}`, '--no-sandbox', '--disable-setuid-sandbox' ] } const browser = await puppeteer.launch(options) expect(browser).toBeTruthy() await browser.close() }, 5000) }) </code></pre><!--kg-card-end: markdown--><h2 id="distributing">Distributing</h2><p>Getting your extension on the web store is a three part process.</p><h3 id="1-package-your-code-into-a-zip-file">1. Package your code into a zip file</h3><p>Your extension needs to be uploaded to Google as a zip. You can have your build tool create a zip file for you. We “stole” this script from <a href="https://github.com/Kocal/vue-web-extension">Kocal’s vue-web-extension</a> repo, check it out in the <a href="https://github.com/checkly/puppeteer-recorder/tree/master/scripts">scripts directory</a>.<br>Kudos to Kocal and Kudos to Google for keeping the distribution format as simple as a zip 👌.</p><h3 id="2-create-a-chrome-web-store-developer-account">2. Create a Chrome Web Store Developer account</h3><p>Set up a developer account on the web store at <a href="https://chrome.google.com/webstore/developer/dashboard">https://chrome.google.com/webstore/developer/dashboard</a></p><p>Note: before publishing, you have to pay a $5 one time fee. Ok, whatever, seems fair.</p><h3 id="3-provide-images-and-a-video">3. Provide images and a video</h3><p>Don’t skimp this! <em>Het oog wil ook wat</em> we say in Dutch, which translates to “Don’t leave the eye wanting!”. Kudos to Google for giving you many branding and promotion options: icons, promotional images in various sizes, a Youtube link to a demo etc.</p><!--kg-card-begin: embed--><figure class="kg-card kg-embed-card"><iframe width="459" height="344" src="https://www.youtube.com/embed/CDzwbm_b7Co?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></figure><!--kg-card-end: embed-->
]]>
            </content:encoded>
        </item>
        <item>
            <title>
                <![CDATA[
Seven discernible stages in taking a solo startup from beta to launch
]]>
            </title>
            <description>
                <![CDATA[
Last week the “beta” tag officially came off of Checkly 🍾🎉! I bumped into many things in the period between launching a private beta and hammering down on all features and ripping the beta notice of the nav.navbar.
]]>
            </description>
            <link>
https://blog.checklyhq.com/seven-discernible-stages-in-taking-a-solo-startup-from-beta-to-ga/
            </link>
            <guid isPermaLink="false">5c87c419ee926100c00d6a95</guid>
            <category>
                <![CDATA[ building a saas ]]>
            </category>
            <dc:creator>
                <![CDATA[ Tim Nolet ]]>
            </dc:creator>
            <pubDate>Fri, 03 Aug 2018 13:37:00 GMT</pubDate>
            <media:content url="https://blog.checklyhq.com/content/images/2019/03/crossing.png" medium="image"/>
            <content:encoded>
                <![CDATA[
<img src="https://blog.checklyhq.com/content/images/2019/03/crossing.png" alt="Seven discernible stages in taking a solo startup from beta to launch"><p>Last week the “beta” tag officially came off of Checkly 🍾🎉! I bumped into many things in the period between <a href="https://hackernoon.com/things-i-learned-from-my-saas-projects-private-beta-period-cd69a11d9e58">launching a private beta</a> and hammering down on all features and ripping the beta notice of the nav.navbar. In this post, I tried to funnel a bunch of these learnings into a somewhat logical order, as they felled like hoops I had to jump through to get to the next hoop.</p><blockquote>Note: Don’t take any of this as gospel. Every situation is different. Stay critical.</blockquote><h2 id="1-taking-payments-with-stripe">1. Taking payments with Stripe</h2><p>Once you ask for money, it becomes real. If you have no way to get money, it never becomes real. No brainer, but this is where it starts. And “yes”, you can ask money for a product in beta. I did and people paid.</p><p>I actually added a pricing page and a way to pay some months before I actively started steering users towards the paid plans. Stripe get’s good press for its developer friendliness but integration was more of a hassle than I expected.</p><ol><li>Discounts can only be applied <strong>AFTER</strong> a person has signed up for a subscription. That’s pretty weird from the customer perspective. Also, their widgets have no input box for coupons.</li><li>Stripe introduced Billing as a separate product, merged Subscriptions into it and put everyone in some weird starter plan. No one got it. <a href="https://news.ycombinator.com/item?id=16766846">CEO had to jump into the Hacker News thread</a>.</li><li>No real business metrics, as in none. Now I understand the market for services like Chargebee, Chargify, Baremetrics etc.</li></ol><p>On that note, the Stripe test sandbox is great.</p><h2 id="2-getting-launching-customers">2. Getting launching customers</h2><p>Once I had the means of receiving money I offered a discount in the form of <em>x-months-for-free</em> to some early users I was emailing with. Rationale is that there is no out-of-pocket cost and the minimal infrastructure is already running: might as well use it. Three rules I forced myself to stick to:</p><ol><li>Don’t offer it to everyone and <strong>don’t offer it straight of the bat</strong>. It should not be the prime driver.</li><li>The new customer has to actually sign up with <strong>a valid credit card</strong>. The discount is applied afterward.</li><li>In exchange for the discount, the customer agrees with a <strong>testimonial</strong>I can use on a landing page.</li></ol><p>Shame on me for completely breaking the payment flow in a botched UI update. Praise on an early customer for graciously waiting some hours and not fleeing the scene! 😅</p><h2 id="3-the-but-they-have-that-rabbit-hole">3. The “but they have that” rabbit hole</h2><p>Pretty soon, early users started comparing features and pricing to a wide range of other services. From free to quadruple the price. From very basic to super advanced.</p><p>Now, Checkly was still in beta and maybe even alpha for some parts so there was some room to expand features or add options to existing features. I added a weekly status email, SSL certificate expiry monitoring and SMS alerts partly based on these comparisons early users made.</p><p>This checklist mentality is sometimes very hard to balance at such an early stage, but I told myself that it if takes one simple objection off the table, adds one new launching customer AND the feature fits with the product strategy it’s worth pursuing.</p><h2 id="4-the-one-more-feature-trap">4. The “one more feature” trap</h2><p>The “but they have that” rabbit hole neatly segs into the “one more feature” trap, although they are slightly different. One is external and comes from users pointing at other services, while the other is internal and comes mostly from myself justifying the price vs. feature balance.</p><p>The “one more feature” trap is a pretty well known trope of the startup industry so I was prepared for it. It turns out not prepared enough, as I added some major new things like <a href="https://checklyhq.com/docs/alerting/settings/#double-checking">double checks</a>, <a href="https://checklyhq.com/docs/browser-checks/triggers/">triggers</a> and <a href="https://checklyhq.com/docs/teams/">teams</a>. Sorry, totally failed on this one.</p><!--kg-card-begin: embed--><figure class="kg-card kg-embed-card"><blockquote class="twitter-tweet"><p lang="en" dir="ltr">The internet can be flaky and glitchy. That&#39;s why we just introduced &quot;double checking&quot;. Every check is now retried if it fails, just to be sure and avoid false positives. <a href="https://t.co/DJvOrpBPcf">https://t.co/DJvOrpBPcf</a><a href="https://t.co/OxK25eiBh1">pic.twitter.com/OxK25eiBh1</a></p>&mdash; Checkly (@checklyHQ) <a href="https://twitter.com/checklyHQ/status/978185749421051904?ref_src=twsrc%5Etfw">March 26, 2018</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></figure><!--kg-card-end: embed--><h2 id="5-the-buy-vs-build-dilemma">5. The buy vs. build dilemma</h2><p>If you’re starting a SaaS then your next hobby will be collecting other SaaS-es. Hosting, email, payments, databases the list goes on. Here’s what I’m paying now, straight from the credit card slip:</p><ol><li><strong>Heroku</strong> ~$75. Totally worth it.</li><li><strong>Github</strong> $7 for private repo’s. I’m so used to the Github flow that I can’t be bothered to Gitlab or Bitbucker for free private repo’s.</li><li><strong>Docker</strong> $7 for private repo’s. This just works. All others I tried were either more expensive or cumbersome.</li><li><strong>Google Gsuite</strong> $5 for mail and other tools.</li><li><strong>Solarwinds</strong> $7 for graphs &amp; monitoring.</li><li><strong>Amazon Web Services</strong> $0. Due to $1000 credit on the <a href="https://aws.amazon.com/activate/">AWS Activate program</a>. This will change and be a more significant cost center in the future.</li></ol><p>I left out the services for which I’m still on the free plan or that have no paid tier, like <strong>Twitter, Trello, Mailchimp, Google Analytics, Hotjar and Heap</strong>. I use all of these, some daily some bi-weekly.</p><p>Now, I could have probably build some pretty crappy versions of what these services provide Checkly with <em>just</em> some EC2 instances and about 8 years of solid engineering time. Silly me, I chose not to!</p><h2 id="6-the-acquihire-distraction">6. The acquihire distraction</h2><p>What 😱 !! Yes, I spend some time meeting with the nice folks of a pretty big tech player discussing a possible acquihire/acquisition of me and Checkly at this early stage. This is enough material for another post, suffice to say we didn’t strike a deal in the end and parted ways on good terms. Also, it didn’t really derail me that much. More later.</p><h2 id="7-the-80-20-engineer-sales-division-">7. The <sup>80</sup>⁄<sub>20</sub> - engineer/sales division.</h2><p>During beta period, I roughly divided my time into 80% engineering and 20% marketing and sales. Now I’m flipping that. I’ll be spending 80% of my time emailing, tweeting, blogging, calling and talking to users to get more launching customers.</p><p>Notice that the above list of expenditures and monthly costs does not include any marketing outlay. This is not <em>completely</em> fair as I did spend around $250 on playing around with Twitter and Betalist to get beta users, which I wrote about <a href="https://hackernoon.com/things-i-learned-from-my-saas-projects-private-beta-period-cd69a11d9e58">here</a></p><p>However, will I probably delay any serious paid marketing until get to a certain amount of customers strictly through my network and through organic, non-paid traffic. There is no real substitute for elbow grease at this early stage.</p>
]]>
            </content:encoded>
        </item>
    </channel>
</rss>